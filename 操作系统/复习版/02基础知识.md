# 1 什么是僵尸进程？什么是孤儿进程？有什么危害？

> 僵尸进程

即子进程先于父进程退出后，子进程的PCB需要其父进程释放，但是父进程并没有释放子进程的PCB，这样的子进程就称为僵尸进程，僵尸进程实际上是一个已经死掉的进程，但在进程表（processs table）中仍占了一个位置（slot）。由于进程表的容量是有限的，所以，defunct 进程不仅占用系统的内存资源， 影响系统的性能，而且如果其数目太多，还会导致系统瘫痪。 

> 处理僵尸进程 

1. 一种比较暴力的做法是将其父进程杀死，那么它的子进程，即僵尸进程会变成孤儿进程，由系统来回收。但是这种做法在大多数情况下都是不可取的，如父进程是一个服务器程序，如果为了回收其子进程的资源，而杀死服务器程序，那么将导致整个服务器崩溃，得不偿失。 
2. 改写父进程，在子进程死后要为它收尸。具体做法是处理 SIGCHLD 信号。子进程死后，会发送 SIGCHLD 信号给父进程，父进程收到此信号后，执行 waitpid () 函数为子进程收尸。

注意：wait函数处理僵尸进程会阻塞，所以如果同时有几个僵尸进程发出SIGCHLD信号，父进程在阻塞期间可能会错过其中几个信号。所以使用 waitpid () 函数，只有检验没有僵尸进程，他才会返回0，这样就可以确保所有的僵尸进程都被杀死了。 

```c
void deal_child(int sig_no)
{
    for (;;) {
 
        if (waitpid(-1, NULL, WNOHANG) == 0)
            break;
    }  
}
```

把父进程杀掉。父进程死后，僵尸进程成为” 孤儿进程”，过继给 1 号进程 init，init 始终会负责清理僵尸进程．它产生的所有僵尸进程也跟着消失。 

> 孤儿进程

父进程运行结束，但子进程还在运行 (未运行结束) 的子进程就称为孤儿进程。 孤儿进程最终会被 init 进程 (进程号为 1) 所收养，因此 init 进程此时变成孤儿进程的父进程，并由 init 进程对它们完成状态收集工作。





# 2 CPU 的上下文切换有几种？系统中断进行了几次上下文切换？

上下文切换 (Context Switch) 是一种将 CPU 资源从一个进程分配给另一个进程的机制。作系统需要先存储当前进程的状态 (包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。 

> CPU 的上下文切换分三种：进程上下文切换、线程上下文切换、中断上下文切换。 

- 系统调用过程中也会发生 CPU 上下文切换。CPU 寄存器会先保存用户态的状态，然后加载内核态相关内容。系统调用结束之后，CPU 寄存器要恢复原来保存的用户态，继续运行进程。所以，一次系统调用，发生两次 CPU 上下文切换。 
- 进程是由内核管理和调度的，进程的切换只能发生在内核态。进程上下文切换与系统调用的不同在于，进程的调用会保存用户空间的虚拟内存，全局变量等信息，但是系统调用的上下文则不会，因为其未发生进程的变化。 
- 内核中的任务调度实际是在调度线程，进程只是给线程提供虚拟内存、全局变量等资源。线程上下文切换时，共享相同的虚拟内存和全局变量等资源不需要修改。而线程自己的私有数据，如栈和寄存器等，上下文切换时需要保存。





# 3 进程的通信方式？效率最高的通信方式是什么？ 





# 4 进程调度算法有几种？应用最广泛的是什么？ 

