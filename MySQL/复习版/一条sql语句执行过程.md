### 1 查询语句

先分析下查询语句，语句如下：

```mysql
select * from tb_student  A where A.age='18' and A.name=' 张三 ';
```

执行流程：权限校验--->（如果命中缓存）查询缓存--->分析器（词法分析，语法分析）--->优化器（执行计划生成，索引选择）--->权限校验--->执行器（操作引擎，返回结果）

1. 先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 sql 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。



2. 通过分析器进行词法分析，提取  sql 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为  tb_student,需要查询所有的列，查询条件是这个表的 id='1'。然后判断这个 sql  语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。



3. 接下来就是优化器进行确定执行方案，上面的 sql 语句，可以有两种执行方案：

```
  a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。
  b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。
```

  那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。

4. 进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。



### 2 更新语句

sql 语句如下：

```mysql
 update T set c=c+1 where ID=2;
```

大致流程：

权限校验--->（如果命中缓存）查询缓存---> 分析器----> 优化器 ---> （权限校验）----> 执行器（执行器负责具体执行，找到这一行，然后更新 ）---> redo log(prepare 状态---> binlog---> redo log(commit状态) 



**具体流程：**

1. 执行器先找引擎取 ID=2 这一行 ， ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器，否则，需要先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的行数据 ，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。 
3. InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。
4. 执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。
5. 更新完成。



**redo log** ： redo log 是 InnoDB 独有的，属于存储引擎层的 。

 具体来说，当有一条记录更新的时候，InnoDB 引擎就会先把记录写到 redo log 里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 会在适当的时候，将这个操作记录更新到磁盘里面.

> PS：InnoDB 的 redo log 是固定大小的， 比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么总共就可以记录 4GB 的操作。使用循环写入的方式，从头开始写，写到末尾就又回到开头循环写，当 redo log 被写满时候，就flush一些redo log 的日志到磁盘 

有了 redo log，**InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失**，这个能力称为**crash-safe**



### 3 其他问题

##### 3.1 **binlog 和 redo log 的不同**

-  redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。
- redo log 是物理日志，记录的是“在某个数据页上做了什么修改”
-  binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。
- redo log 是循环写的，空间固定会用完；
- binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。





##### 3.2 **为什么会有两份日志?**

因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。

 而 InnoDB 是另一个公司以插件形式引入 MySQL 的，所以 InnoDB 使用 redo log 来实现 crash-safe 能力。



##### 3.3 **为什么要有两阶段提交?**

- **先写 redo log 直接提交，然后写 binlog**，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 bingog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。
- **先写 binlog，然后写 redo log**，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。

假设 redo log 处于预提交状态，binglog  也已经写完了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：

- 判断 redo log 是否完整，如果判断是完整的，就立即提交。
- 如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。

这样就解决了数据一致性的问题。





### 4 总结

- MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用,redolog 只有 InnoDB 有。

- redo log 用于保证 crash-safe 能力。

  innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。

   这个参数建议设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。

- sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。

  这个参数也建议设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。

 