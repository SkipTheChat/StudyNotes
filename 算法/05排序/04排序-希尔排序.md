# 希尔排序

#### 1.问题描述

我们看简单的插入排序可能存在的问题.
数组arr = {2,3,4,5,6,1} 这时需要插入的数1(最小), 这样的过程是：
{2,3,4,5,6,6}
{2,3,4,5,5,6}
{2,3,4,4,5,6}
{2,3,3,4,5,6}
{2,2,3,4,5,6}
{1,2,3,4,5,6}
结论: 当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响.



#### 2.解决思路

将集合进行分组，先进行组排序，最后再进行一次插入排序。

有一个集合如下图所示： ![5.4.1](https://raw.githubusercontent.com/SkipTheChat/-algorithm/master/assets/5.4.1.png)

**计算增量：gap = length/2 = 4**

* 第一次：gap = 4，把待排序列划分为4个子序列 

![5.4.2](https://raw.githubusercontent.com/SkipTheChat/-algorithm/master/assets/5.4.2.png)



* 第二次 ：gap =2/ 2 = 2，把待排序列划分为2个子序列 

![5.4.3](https://raw.githubusercontent.com/SkipTheChat/-algorithm/master/assets/5.4.3.png)



* 第三次：gap =2/2=1，**进行一次直接插入排序**，排序结束 。

  

* 排序结果： 

![5.4.4](https://raw.githubusercontent.com/SkipTheChat/-algorithm/master/assets/5.4.4.png)



#### 3.代码

> 代码实现：推荐用移位排序，效率更高。

```
package demo;

import java.util.Arrays;

public class ShellSort {

    public static void main(String[] args) {
        int[] arr = { 8, 9, 1,7, 2, 3, 5, 4, 0};
//        shellSort(arr); //交换式
        shellSort2(arr);//移位方式
        System.out.println(Arrays.toString(arr));
    }



    // 希尔排序时， 对有序序列在插入时采用交换法,
    public static void shellSort(int[] arr) {
        int temp = 0;
        // 控制组数，逐渐对半减少一直到1
        for (int gap = arr.length / 2; gap > 0; gap /= 2) {
            //当i=1时，就是纯插入排序的逻辑了。
            for (int i = gap; i < arr.length; i++) {
                //j-=gap表示控制j<=gap，且要控制j>=0
                for (int j = i - gap; j >= 0; j -= gap) {
                    if (arr[j] > arr[j + gap]) {
                        temp = arr[j];
                        arr[j] = arr[j + gap];

                        arr[j + gap] = temp;
                    }
                }
            }
        }
    }

      //对交换式的希尔排序进行优化->移位法
    public static void shellSort2(int[] arr) {
        int temp = 0;
        for (int gap = arr.length / 2; gap >=1 ; gap = gap / 2) {
            for (int i = gap; i < arr.length; i++) {
                temp = arr[i];
                int j = i - gap;

                if(arr[i] < arr[j]){
                    while(j >= 0 && temp < arr[j]){
                        arr[j + gap] = arr[j];
                        j = j -gap;
                    }
                        arr[j +gap] = temp;
                }

                }
            }
        }

}
```



参考博客：https://www.jianshu.com/p/a49e9c1998d1