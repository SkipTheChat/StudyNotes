# 1 单点登录

[博客](https://www.jianshu.com/p/613e44d4a464)

单点登录SSO（Single Sign  On），也就是用户的一次登录能得到其他所有系统的信任。

### 1.1 以Cookie作为凭证媒介

 最简单的单点登录实现方式，是使用cookie作为媒介，存放用户凭证。 
 用户登录父应用之后，应用返回一个加密的cookie，当用户访问子应用的时候，携带上这个cookie，授权应用解密cookie并进行校验，校验通过则登录当前用户。

![这里写图片描述](https://img-blog.csdn.net/20161123092035062)

不难发现以上方式把信任存储在客户端的Cookie中，这种方式很容易令人质疑：

- Cookie不安全
- 不能跨域实现免登

对于第一个问题，通过加密Cookie可以保证安全性，当然这是在源代码不泄露的前提下。如果Cookie的加密算法泄露，攻击者通过伪造Cookie则可以伪造特定用户身份，这是很危险的。 
 对于第二个问题，更是硬伤。



### 2 通过JSONP实现

 对于跨域问题，可以使用JSONP实现。 

![这里写图片描述](https://img-blog.csdn.net/20161123092145251)

这种方式虽然能解决跨域问题，但是安全性其实跟把信任存储到Cookie是差不多的。



##### 3.1 jsonp实现原理

动态添加一个<script>标签，script标签的src属性是没有跨域的限制的。 





### 3 通过页面重定向的方式 

 父应用提供一个GET方式的登录接口，用户通过子应用重定向连接的方式访问这个接口，如果用户还没有登录，则返回一个的登录页面，用户输入账号密码进行登录。如果用户已经登录了，则生成加密的Token，并且重定向到子应用提供的验证Token的接口，通过解密和校验之后，子应用登录当前用户。

![这里写图片描述](https://img-blog.csdn.net/20161123092255186)

这种方式较前面两种方式，接解决了上面两种方法暴露出来的安全性问题和跨域的问题，但是并没有前面两种方式方便。 
 安全与方便，本来就是一对矛盾。



### 4 使用独立登录系统 

 一般说来，大型应用会把授权的逻辑与用户信息的相关逻辑独立成一个应用，称为用户中心。 
 用户中心不处理业务逻辑，只是处理用户信息的管理以及授权给第三方应用。第三方应用需要登录的时候，则把用户的登录请求转发给用户中心进行处理，用户处理完毕返回凭证，第三方应用验证凭证，通过后就登录用户。

要点：

token是识别客户端身份的唯一标示，如果加密不够严密，被人伪造那就完蛋了。

采用何种方式加密才是安全可靠的呢？

可以采用`JWT + RSA非对称加密`

### 4.1 jwt

包括Header，Payload，Signature三部分。

流程：

- 1、用户登录
- 2、服务的认证，通过后根据secret生成token
- 3、将生成的token返回给浏览器
- 4、用户每次请求携带token
- 5、服务端利用公钥解读jwt签名，判断签名有效后，从Payload中获取用户信息
- 6、处理请求，返回响应结果

因为JWT签发的token中已经包含了用户的身份信息，并且每次请求都会携带，这样服务的就无需保存用户信息，甚至无需去数据库查询，完全符合了Rest的无状态规范。





### 4.2 RSA

![](../assets/2.6.png)

结合RSA的认证流程：

- 我们首先利用RSA生成公钥和私钥。私钥保存在授权中心，公钥保存在Zuul和各个信任的微服务
- 用户请求登录
- 授权中心校验，通过后用私钥对JWT的token进行签名加密
- 返回jwt给用户
- 用户携带JWT访问
- Zuul直接通过公钥解密JWT，进行验证，验证通过则放行
- 请求到达微服务，微服务直接用公钥解析JWT，获取用户信息，无需访问授权中心





# 2 URI和URL的区别

* URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。
* URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。

URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。



**示例：**

request.getRequestURI() 返回值类似：/xuejava/requestdemo.jsp  

 request.getRequestURL() 返回值类似：<http://localhost:8080/xuejava/requestdemo.jsp> 

**所以说URI更像一个人的名片，而URL是这个人的名片+地址。**





# 3 简单说一下 http2.0

[博客](https://blog.csdn.net/zhuyiquan/article/details/69257126?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase)

HTTP/2 的目的是通过支持请求与响应的多路复用来较少延迟，通过压缩HTTPS首部字段将协议开销降低，同时增加请求优先级和服务器端推送的支持。  

## 3.1 **二进制分帧层**

HTTP 1.x在应用层以纯文本的形式进行通信，而HTTP 2.0将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码。这样，客户端和服务端都需要引入新的二进制编码和解码的机制。
如下图所示，HTTP 2.0并没有改变HTTP 1.x的语义，只是在应用层使用**二进制分帧方式传输**



## 3.2 **多路复用共享连接**

基于二进制分帧层，HTTP 2.0可以在共享TCP连接的基础上，同时发送请求和响应。HTTP消息被分解为独立的帧，而不破坏消息本身的语义，交错发送出去，最后在另一端根据流ID和首部将它们重新组合起来。
我们来对比下HTTP 1.x和HTTP 2.0，假设不考虑1.x的pipeline机制，双方四层都是一个TCP连接。客户端向服务度发起三个图片请求/image1.jpg，/image2.jpg，/image3.jpg。
HTTP 1.x发起请求是串行的，image1返回后才能再发起image2，image2返回后才能再发起image3。 

而HTTP 2.0建立一条TCP连接后，并行传输着3个数据流，客户端向服务端乱序发送stream1~3的一系列的DATA帧，与此同时，服务端已经在返回stream 1的DATA帧 。

![](../assets/3.1.1.jpg)



所以HTTP2.0 使用多路复用的技术，做到了同一个连接并发处理多个请求，而且并发请求的数量比 HTTP1.1 大了好几个数量级。 

当然 HTTP1.1 也可以多建立几个 TCP 连接，来支持处理更多并发的请求，但是创建TCP 连接本身也是有开销的。



> 瓶颈

HTTP 2.0会带来新的性能瓶颈。因为现在所有的压力集中在底层一个TCP连接之上，TCP很可能就是下一个性能瓶颈，比如TCP分组的队首阻塞问题，单个TCP packet丢失导致整个连接阻塞，无法逃避，此时所有消息都会受到影响。 





# 4 HTTPS 

[][https://blog.csdn.net/hherima/article/details/52469267]

[HTTPS协议详解(一)：HTTPS基础知识](http://blog.csdn.net/hherima/article/details/52469267)  

[HTTPS协议详解(二)：TLS/SSL工作原理](http://blog.csdn.net/hherima/article/details/52469360) 

[HTTPS协议详解(四)：TLS/SSL握手过程](http://blog.csdn.net/hherima/article/details/52469674)

[HTTPS协议详解(五)：HTTPS性能与优化](http://blog.csdn.net/hherima/article/details/52469787) 



## 4.1 基础知识

TLS/SSL全称安全传输层协议Transport Layer Security, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。
![](../assets/2.1.png)



##### 4.1.1 什么是HTTPS

HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。HTTPS主要作用是：
（1）对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;
（2）对网站服务器进行真实身份认证。

##### 4.1.2 什么是HTTP

​    HTTP是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准(TCP)，用于从WWW服务器传输超文本到本地浏览器的传输协议。HTTP是采用明文形式进行数据传输，极易被不法份子窃取和篡改。

##### 4.1.3 HTTPS和HTTP的区别是什么

![](../assets/2.2.png)

1. HTTPS是加密传输协议，HTTP是明文传输协议;
2. HTTPS需要用到SSL证书，而HTTP不用;
3. HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO【参考：（1）为保护用户隐私安全,谷歌优先索引HTTPS网页、（2）百度开放收录https站点，https全网化势不可挡】;
4. HTTPS标准端口443，HTTP标准端口80;
5.  HTTPS基于传输层，HTTP基于应用层;
6.  HTTPS在浏览器显示绿色安全锁，HTTP没有显示;

​    总的来说HTTPS比HTTP更加安全，能够有效的保护网站用户的隐私信息安全，这也是为什么现在的HTTPS网站越来越多。





## 4.2 加密算法

HTTPS一般使用的加密与HASH算法如下：

非对称加密算法：RSA，DSA/DSS

对称加密算法：AES，RC4，3DES

HASH算法：MD5，SHA1，SHA256



## 4.3 TLS/SSL握手过程

**https** **是否存在安全问题？如何避免？** 

当服务器发送公钥给客户端， 中间人截获公钥 ，将 中间人自己的公钥 冒充服务器的公钥发送给客户端。之后客户端会用 中间人的的公钥 来加密自己生成的 对称密钥 。然后把加密的密钥发送给服务器，这时中间人又把密钥截取，中间人用自己的私钥把加密的密钥进行 

解密，解密后中间人就能获取 对称加密的密钥 。

**为了应对上面非对称加密带来的问题，我们就引入了数字证书与数字签名:**

故CA认证介入我们的HTTPS连接的过程如下：

1、服务器拥有自己的私钥与公钥

2、服务器将公钥交给CA认证机构，请求给予一份数字证书

3、CA认证机构生成数字证书，并颁发给服务器

4、服务器将带有公钥信息的数字证书发给客户端

5、客户端使用 CA 提供的公钥对数字证书里的数字签名进行解密来得到信息摘要，然后对数字证书里服务器的公钥及个人信息进行 Hash 得到另一份信息摘要 。最后将两份信息摘要对比，如果一样则证明是服务器，否则就是中间人。

6、客户端生成随机数，作为对称加密的密钥 B，并使用服务器返回的公钥 A，对自己生成的对称加密密钥 B 进行加密，得到密钥C

7、客户端将秘钥C发送给服务端

8、服务器使用自己的非对称加密私钥 D 对接受的密钥 C 进行解密，得到对称加密密钥B。 

9、客户端和服务器之间使用密钥 B 作为对称加密密钥进行通信。




## 4.4 HTTPS性能与优化

https缺点:

（1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；

（2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；

（3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。

（4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。

（5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。




>  见博客





# 5 HTTP长连接和短连接

[博客](https://www.cnblogs.com/gotodsp/p/6366163.html)

## 5.1 HTTP协议与TCP/IP协议的关系

HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。  IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP协议是可靠的、面向连接的。



## 5.2 什么是长连接、短连接？

在HTTP/1.0中默认使用短连接。

短连接是指SOCKET连接后，发送接收完数据后马上断开连接。 也就是客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。

而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：

> Connection:keep-alive

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。





## 5.3 长连接和短连接的优点和缺点

**长连接：**

- 优点：可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。**对于频繁请求资源的客户端适合使用长连接。**
- 缺点：在长连接的应用场景下，client端一般不会主动关闭连接，当client与server之间的连接一直不关闭，随着客户端连接越来越多，server会保持过多连接。这时候server端需要采取一些策略，如关闭一些长时间没有请求发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件允许则可以限制每个客户端的最大长连接数，这样可以完全避免恶意的客户端拖垮整体后端服务。



**短连接：**

- 优点：对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。
- 缺点：每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多。如果客户请求频繁，将在TCP的建立和关闭操作上浪费较多时间和带宽。 



## 5.4 应用场景

**长连接**多用于操作频繁，点对点的通讯，而且连接数不能太多情况。例如：**数据库的连接用长连接**，  如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。 

**短链接**：一**般用于像WEB网站的http服务**，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。









# 7 在浏览器中输入url地址 ->> 显示主页的过程

**总体来说分为以下几个过程:**

1. DNS解析
2. TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 连接结束



**DNS解析：将域名解析为ip地址**

1. 主机先向本地域名服务器进行递归查询
2. 本地域名服务器向一个根域名服务器进行查询
3. 根域名服务器告诉本地域名服务器，下一次应该查询的顶级域名服务器的IP地址
4. 本地域名服务器向顶级域名服务器进行查询
5. 顶级域名服务器告诉本地域名服务器，下一步查询权限服务器的IP地址
6. 本地域名服务器向权限服务器进行查询
7. 权限服务器告诉本地域名服务器所查询的主机的IP地址
8. 本地域名服务器最后把查询结果告诉主机 

（DNS缓存+DNS负载均衡）



**TCP连接：**

三次握手



**HTTPS协议：SSL和TLS加密**

在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。从网络的层级结构看它位于HTTP协议与TCP协议之间。 HTTPS在传输数据之前需要客户端与服务器进行一个握手(TLS/SSL握手)，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL使用了非对称加密，对称加密以及hash等。具体过程请参考经典的阮一峰先生的博客[TLS/SSL握手过程](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)。 HTTPS相比于HTTP，虽然提供了安全保证，但是势必会带来一些时间上的损耗，如握手和加密等过程，是否使用HTTPS需要根据具体情况在安全和性能方面做出权衡。 



**发送HTTP请求：**

1. 建立连接后，客户机发送一个请求报文给服务器.

2. 服务器接到请求后，给予相应的响应报文。

3. 客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。

     渲染过程：浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。 JS的解析是由浏览器中的JS解析引擎完成的。 

如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。



HTTP请求报文主要由请求行、请求头部、请求正文3部分组成。

![](../assets/1.5.png)



**1.请求行**

| 组成部分(之间由空格分隔) | 内容                                                         |
| ------------------------ | ------------------------------------------------------------ |
| 请求方法                 | 包括GET、HEAD、PUT、POST、TRACE、OPTIONS、DELETE以及扩展方法<br>当然并不是所有的服务器都实现了所有的方法，部分方法即便支持，处于安全性的考虑也是不可用的 |
| URL                      | ---                                                          |
| 以及协议版本             | HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1           |





**2.请求头部**

请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔

常见请求头如下：

![](../assets/1.6.png)

请求头部的最后会有一个空行，表示请求头部结束，接下来为请求正文，这一行非常重要，必不可少 



**3.请求正文**

可选部分，比如GET请求就没有请求正文





**HTTP响应报文格式**

HTTP响应报文主要由状态行、响应头部、响应正文3部分组成

![](../assets/1.7.png)

**1.状态行**

由3部分组成，分别为：协议版本，状态码，状态码描述，之间由空格分隔。

| 状态代码 | 含义                               |
| -------- | ---------------------------------- |
| 1xx      | HTTP/1.1向协议中引入了信息性状态码 |
| 2xx      | 表示成功                           |
| 3xx      | 指资源重定向                       |
| 4xx      | 指客户端请求出错                   |
| 5xx      | 指服务端出错                       |

这里列举几个常见的：

![](../assets/1.8.png)



**2.响应头部**

与请求头部类似，为响应报文添加了一些附加信息

常见响应头部如下：

![](../assets/1.9.png)







[具体-博客](https://segmentfault.com/a/1190000006879700)





# 8 各种协议与HTTP协议之间的关系

[超级好的一篇博客，总结了ip/tcp协议簇](https://developer.51cto.com/art/201906/597961.htm#topx)

![](../assets/2.5.png)





# 9  ping用到的协议

通过DNS协议，将ping后接的域名转换为ip地址。（DNS使用的传输层协议是UDP）

通过ARP解析服务，由ip地址解析出MAC地址，以在数据链路层传输。

ping是为了测试另一台主机是否可达，发送一份ICMP回显请求给目标主机，并等待ICMP回显应答。（ICMP用于在ip主机、路由器间传递网络是否通畅、主机是否可达等控制信息）



# 10 客户端或服务端崩了，如何结束连接，对方如何感知 

保险的方法只有心跳包，定时发送，并接受心跳包，一旦超时不到，就断开连接，并回收资源。



# 11 NAT

NAT是网络地址转换，Network Address Translation

因为ip地址比较有限，所以需要很多人共用1个公网ip来访问互联网，而在企业内部通信的时候，不需要使用公网ip，每人都使用私网ip即可。

而访问互联网时，网络边界设备（路由器、防火墙等），会将各个主机的私网ip，转换成公网ip，而这个公网ip是大家共用的，叫做nat技术。

 **因为nat设备通过ip+端口的方式，来识别不同的内部用户，那么1个ip有多少端口将影响到能带多少内部用户。** 



# 12 半连接攻击（syn攻击）

[博客](https://www.jianshu.com/p/eb050f50310b)

**半连接** 

在三次握手过程中，服务器发送SYN-ACK之后，收到客户端的ACK之前的TCP连接称为半连接(half-open connect).此时服务器处于Syn_RECV状态.当收到ACK后，服务器转入ESTABLISHED状态.

**半连接队列** 

在三次握手协议中，服务器维护一个半连接队列，存放半连接。该队列为每个客户端的SYN包（syn=j）开设一个条目，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的ACK确认包。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。

**Backlog参数** 

表示半连接队列的最大容纳数目。

**SYN-ACK 重传次数** 

服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同。

**半连接存活时间** 

是指半连接队列的条目存活的最长时间，也即服务从收到SYN包到确认这个报文无效的最长时间，该时间值是所有重传请求包的最长等待时间总和。有时我们也称半连接存活时间为Timeout时间、SYN_RECV存活时间。

**SYN攻击**

SYN攻击属于DOS攻击的一种，它利用TCP协议缺陷，通过发送大量的半连接请求，耗费CPU和内存资源。 

SYN攻击利用TCP协议三次握手的原理，大量发送伪造源IP的SYN包也就是伪造第一次握手数据包，服务器每接收到一个SYN包就会为这个连接信息分配核心内存并放入半连接队列，如果短时间内接收到的SYN太多，半连接队列就会溢出，操作系统会把这个连接信息丢弃造成不能连接，当攻击的SYN包超过半连接队列的最大值时，正常的客户发送SYN数据包请求连接就会被服务器丢弃。目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。



# 13 MAC地址长度知道么？如何保证每台机器地址不同 

一般为6字节48bit

前24位由是生产厂家向IEEE申请的厂商地址，后24位（UAA）就由生产厂家自行定义。  



# 14 路由器如何工作

 路由器是工作在**网络层**的设备。路由器负责将数据分组从源端主机经最佳路径传送到目的端主机。路由器主要用于同类或异类局域网以及局域网与广域网之间的互联。是连接不同逻辑子网的网络互连设备。路由器具有异构网络互连，广域网互连，和隔离广播信息的能力。

**路由器的基本功能**   

1、路由选择     

路由选择就是路由器依据目的IP地址的网络地址部分，通过路由选择算法确定一条从源结点到达目的结点的最佳路由。   

路由器通过路由协议，网络连接的情况及网络的性能来建立网络的拓扑结构。路由算法为网络上的路由产生一个权值，路由器通过权值来选择最佳路径，权值越小，路由最佳。       

对于一台路由器，其分组转发的任务即是在收到数据包后，根据路由表所提供的最佳路径的信息，将其转发给下一条的路由器，目的端口或是缺省路由器。

2、路由表   

路由表通过对路由表的查询来选择最佳路径的策略，路由表中保存着各种传输路径的相关数据，供路由选择时使用。   

路由表的内容主要包括：  

1、目的网络地址及其所对应的目的端口   

2、下一跳路由器的名字  

3、缺省路由的信息  







 

# 14 CLOSE_WAIT状态的原因与解决方法  time_wait 

https://blog.csdn.net/libaineu2004/article/details/78886182   





# 15  TCP通信粘包问题分析和解决

[博客](https://www.jianshu.com/p/cf5417d26bb9)



还有几个下次整合

