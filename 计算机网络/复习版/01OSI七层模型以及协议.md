# 1 OSI模型



![](../assets/1.28.jpg)

![](../assets/3.1.png)

![](../assets/3.2.png)



# 2 概览

| OSI七层模型 | 功能                                                         | 对应的网络协议      | TCP/IP四层概念模型 |
| ----------- | ------------------------------------------------------------ | ------------------- | ------------------ |
| 应用层      | 是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。 | HTTP、TFTP, FTP     | 应用层             |
| 表示层      | 可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 | telnet、SNMP        |                    |
| 会话层      | 通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名） | SMTP, DNS           |                    |
| 传输层      | 定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（[用户数据报协议](http://baike.baidu.com/view/468464.htm)，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。 | TCP, UDP            | 传输层             |
| 网络层      | 在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。 | IP, ICMP, ARP, RARP | 网络层             |
| 数据链路层  | 定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。 |                     | 数据链路层         |
| 物理层      | 主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 |                     |                    |



![](../assets/1.30.jpeg)

![](../assets/1.31.jpeg)



- 数据链路层：以太网包首部-mac地址
- 网络层：ip包首部-识别 TCP/IP网络中互连的主机和路由器
- 传输层：端口号--用来识别同一台计算机中进行通信的不同应用程序







# 3 网络层

## 3.1 IP协议

##### 3.1.1 IP协议功能

（1）寻址和路由；（根据对方的IP地址，寻找最佳路径传输信息）；

（2）传递服务：

​	① 不可靠（IP协议只是尽自己最大努力去传输数据包），可靠性由上层协议提供（TCP协议）；	

​	② 无连接（事先不建立会话），不维护任何关于后续数据报的信息；

（3）数据包的分片和重组。



##### 3.1.2  IP报文格式

![](../assets/1.21.png)





## 3.2 ICMP- Internet控制信息协议

Internet Control Message Protocol 

一个新搭建好的网络，往往需要先进行一个简单的测试，来验证网络是否畅通；但是IP协议并不提供可靠传输。如果丢包了，IP协议并不能通知传输层是否丢包以及丢包的原因。   所以我们就需要一种协议来完成这样的功能–ICMP协议。 



##### 3.2.1 功能

ICMP协议的功能主要有：   

1. 确认IP包是否成功到达目标地址   

![](../assets/1.24.png)



注意：  ICMP只能搭配IPv4使用，如果是IPv6的情况下, 需要是用ICMPv6 



##### 3.2.3 报文类型

ICMP大概分为两类报文：  

一类是通知出错原因 ；一类是用于诊断查询  

| 类型（十进制） | 内容             |
| -------------- | ---------------- |
| 0              | 回送应答         |
| 3              | 目标不可达       |
| 4              | 原点抑制         |
| 5              | 重定向或改变路由 |
| 8              | 回送请求         |
| 9              | 路由器公告       |
| 10             | 路由器请求       |
| 11             | 超时             |
| 17             | 地址子网请求     |
| 18             | 地址子网应答     |



##### 3.2.4 时间戳请求

时间戳请求报文（类型值字段13）和时间戳应答报文（类型值字段14）用于测试两台主机之间数据报来回一次的传输时间。 
 传输时，主机填充原始时间戳，接受方收到请求后填充接受时间戳后以类型值字段14的报文格式返回，发送方计算这个时间差。



##### 3.2.5 常见应用-ping

我们用的ping操作中就包括了相应请求（类型字段值为8）和应答（类型字段值为0）ICMP报文。

**过程：**
一台主机向一个节点发送一个类型字段值为8的ICMP报文，如果途中没有异常（如果没有被路由丢弃，目标不回应ICMP或者传输失败），则目标返回类型字段值为0的ICMP报文，说明这台主机存在。



**功能**：

（1）能验证网络的连通性   

（2）会统计响应时间和TTL(IP包中的Time To Live，生存周期)



**问题：**

telnet是23端口，ssh是22端口，那么ping是什么端口?    答：ping命令是基于ICMP，是在网络层。   而端口号，是传输层的内容。所以在ICMP中根本就不关注端口号这样的信息。  





##### 3.2.6 traceroute

traceroute也是基于ICMP协议实现的。   

**功能：**   打印出可执行程序主机，一直到目标主机之前经历多少路由器。   

**工作原理  ：**

是利用ICMP差错控制报文中的TTL超时会回向源点发送一个时间超时报文。例如A 主机 traceroute  B主机，A会封装一些分组，这些分组很特殊，例如第一个分组的TTL设置为1 ，第二个分组的TTL设置为2  以此类推.......当第一个分组到达第一个路由器时，发现TTL变成了0就会给源主机发送一个时间超时报文，这也就知道了这个分组所经过的一个路由器，同理可得。 当最后一个分组到达B主机时。收集每个时间超时的报文中的IP 就获得了A主机到B主机的路径。 



举例如下：  

![](../assets/1.26.png)

**域名可以通过DNS解析为IP地址**







## 3.3 ARP-地址解析协议

**地址解析协议（Address Resolution Protocol）** 

##### 3.3.1 功能

我们都知道局域网里面通信，都是靠**MAC地址**来通信的。ARP简单说，就是用来把IP地址转换成MAC地址，就是某个去往目的IP地址翻译成MAC地址。



##### 3.3.2 原理

示例：

![](../assets/1.27.jpg)

电脑从上层往下封装，到了二层，要封装帧头部时，就需要把目的mac地址封装上，形成完整的二层头部后，就可以发送出去了。 

现在的问题就是，电脑如何知道对方的MAC地址？ 

这时候，计算机A就执行ARP程序，发送一个ARP请求报文的广播包，这样，交换机收到这个报文，看到目的mac地址是全F就广播。

数据包关键字如下：

| 目的MAC地址 | ffff.ffff.ffff.ffff |
| ----------- | ------------------- |
| 源mac地址   | 1111.1111.1111.1111 |
| 类型        | 0x0806              |
| source IP   | 1.1.1.1             |
| target IP   | 1.1.1.2             |

所有的计算机收到这个广播包，会进行更深入的解析，看到里面的target IP 是1.1.1.2,  与自己的IP地址进行对比，发现不一样，就丢弃。发现一样，就回应ARP报文。 

计算机A收到回应的这个报文后，就将计算机E的mac地址记录下来，存在计算机A的一个数据库，叫做ARP缓存表。下次通信时，如果缓存未超时，就可以直接使用了。如果超时了，就再次进行arp请求广播了。 



##### 3.3.3 ARP攻击

ARP协议的基本功能就是通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的进行。 基于ARP协议的这一工作特性，黑客向对方计算机不断发送有欺诈性质的ARP数据包，数据包内包含有与当前设备重复的Mac地址，使对方在回应报文时，由于简单的地址重复错误而导致不能进行正常的网络通信。

一般情况下，受到ARP攻击的计算机会出现两种现象：
1)不断弹出“本机的XXX段硬件地址与网络中的XXX段地址冲突”的对话框。
2) 计算机不能正常上网，出现网络中断的症状。

因为这种攻击是利用ARP请求报文进行“欺骗”的，所以防火墙会误以为是正常的请求数据包，不予拦截。因此普通的防火墙很难抵挡这种攻击。 



##### 3.3.4 ARP代理

用于跨网段访问。

**原理：**

当出现跨网段的ARP请求时，路由器将自己的MAC返回给发送ARP广播请求发送者，实现MAC地址代理（善意的欺骗），最终使得主机能够通信。 

![](../assets/1.28.png)

图中R1和R3处于不同的局域网，R1和R3在相互通信时，R1先发送了一个ARP广播数据包，请求R3的mac地址，但是由于R1是12.1.1.0网段，而R3是13.1.1.0网段，R1和R3之间是跨网段访问的，也就是说R1的ARP请求会被R2拦截到，然后R2会封装自己的mac地址为目的地址发送一个ARP回应数据报给R1（善意的欺骗），然后R2就会代替R1去访问R3。 



## 3.4 RARP-反向地址解析协议

Reverse Address Resolution Protocol 

**作用：**完成硬件地址到IP地址的映射，主要用于无盘工作站，因为无盘工作站配置的IP地址不能保存。

**工作流程：**在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。



# 4 传输层（Transport Layer）

**运输层主要使用以下两种协议:**

1. **传输控制协议 TCP**（Transmission Control Protocol）--提供**面向连接**的，**可靠的**数据传输服务。
2. **用户数据协议 UDP**（User Datagram Protocol）--提供**无连接**的，尽最大努力的数据传输服务（**不保证数据传输的可靠性**）。



## 4.1 TCP

[博客1](https://blog.csdn.net/qq_38950316/article/details/81087809)

[博客2](https://www.cnblogs.com/Andya/p/7272462.html)

### 4.1.1 首部

![](../assets/1.11.png)



1. **源端口和目的端口**，各占2个字节，分别写入源端口和目的端口；
2. **序号seq**，占4个字节，数据是每个字节一个序号 。就是告诉接收方：我发送的数据是从seq开始的。 **当发送syn标记时将消耗一个序号；** **对于要发送的数据的第一个序号而言这个序号是通过一个算法计算得到一个初始序号（ISN）加1** 
3. **确认号ack**，占4个字节，就是告诉接收方：我希望下次收到对端发过来的seq序号值。 
4. **数据偏移**，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；
5. **保留**，占6位，保留今后使用，但目前应都位0；
6. **紧急URG**，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；
7. **确认ACK**，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；
8. **推送PSH**，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；
9. **复位RST，**当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；
10. **同步SYN，**在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；
11. **终止FIN**，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；
12. **窗口**，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；
13. **检验和**，占2字节，校验首部和数据这两部分；
14. **紧急指针**，占2字节，指出本报文段中的紧急数据的字节数；
15. **选项，**长度可变，定义一些其他的可选的参数。



### 4.1.2 三次握手

![](../assets/1.12.png)

而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。

最初两端的TCP进程都处于CLOSED关闭状态，A主动打开连接，而B被动打开连接。



**总结三次握手过程：**

- **第一次握手**：起初两端都处于CLOSED关闭状态，Client将数据包发送给Server，Client进入SYN-SENT状态，等待Server确认；
- **第二次握手**：Server收到数据包后将该数据包发送给Client以确认连接请求，Server进入SYN-RCVD状态，此时操作系统为该TCP连接分配TCP缓存和变量；
- **第三次握手**：Client收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并且此时操作系统为该TCP连接分配TCP缓存和变量，并将该数据包发送给Server，Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client和Server就可以开始传输数据。

0

**为什么A还要发送一次确认呢？可以二次握手吗？**

　　答：**主要为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误**。“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。  本来这是一个早已失效的报文段,但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。  假设不采用“[三次握手](https://www.baidu.com/s?wd=%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送ack包。 



**Server端易受到SYN攻击？**

SYN攻击就是通过向网络服务所在端口发送大量的伪造源地址的攻击报文，就可能造成服务器中的半开连接队列被占满，消耗服务端大量资源从而阻止其他合法用户进行访问。由于它可以方便地伪造源地址,追查起来非常困难。它的数据包特征通常是,源发送了大量的SYN包,并且缺少三次握手的最后一步握手ACK回复。

防范SYN攻击措施：降低主机的等待时间使主机尽快的释放半连接的占用，短时间受到某IP的重复SYN则丢弃后续请求。





### 4.1.3 四次挥手

![](../assets/1.14.png)





数据传输结束后，通信的双方都可释放连接，A和B都处于ESTABLISHED状态。

1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2. 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。
3. 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
5. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
6. ​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。





**为什么A在TIME-WAIT状态必须等待2MSL的时间？**

MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 

答：

这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，B超时重传FIN+ACK报文段，而A能在2MSL时间内收到这个重传的FIN+ACK报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到CLOSED状态，若A在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则B无法正常进入到CLOSED状态。



**为什么连接的时候是三次握手，关闭的时候却是四次握手？**

答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。



### 4.1.4 TCP 协议如何保证可靠传输

[博客](https://blog.csdn.net/liuchenxia8/article/details/80428157)

TCP协议传输的特点主要就是面向字节流、传输可靠、面向连接。

**TCP协议通过使用连续ARQ协议和滑动窗口协议，来保证数据传输的正确性，从而提供可靠的传输。** 

#### **4.1.4.1.校验和**

计算方式：在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和。
发送方：在发送数据之前计算检验和，并进行校验和的填充。
接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。

![](../assets/1.15.png)

注意：如果接收方比对校验和与发送方不一致，那么数据一定传输有误。但是如果接收方比对校验和与发送方一致，数据不一定传输成功。



#### **4.1.4.2.确认应答与序列号**

序列号：TCP传输时将每个字节的数据都进行了编号，这就是序列号。
确认应答：TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。

![](../assets/1.16.png)

序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。





#### **4.1.4.3.连接管理**

连接管理就是三次握手与四次挥手的过程，在前面详细讲过这个过程，这里不再赘述。保证可靠的连接，是保证可靠性的前提。



##### 4.1.4.3.1 ARQ协议

[博客](https://www.cnblogs.com/blythe/articles/7348812.html)

T**CP协议通过使用连续ARQ协议和滑动窗口协议，来保证数据传输的正确性，从而提供可靠的传输。** 

**简介：**

ARQ协议，即自动重传请求，是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用**确认**和**超时**这两个机制，在不可靠服务的基础上实现可靠的信息传输。

ARQ包括停止等待ARQ协议和连续ARQ协议。 



**停止等待ARQ协议** ：

TCP 连接是全双工的连接，也就是说在通信的时候，双方既是发送方，也是接收方。

 **（1）超时重传**

如果A发送的过程中出现差错，B在接收M1时检测出了差错，就丢弃M1，又或者A传送的过程中分组丢失了，以上这两种情况下，B不会发送任何信息。 

既然说它是可靠传输协议，那自然有它可靠的方法：如果发生以上的情况，**A只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，所以它会重传刚刚的发送过的分组**。

超时重传的原理也很简单：发送方发送完一个分组后，就会设置一个**超时计时器**，如果超时计时器到期之前没有收到接收方发来的确认信息，则会重发刚发送过的分组；如果收到确认信息，则撤销该超时计时器。



> 注意：
>
> ①既然发送方发送的分组可能丢失或者有差错，可能需要重传，那么它必须暂时保留已发送的分组副本，只有收到确认后，才清除这个副本。
>
> ②分组和确认分组信息都应该有各自的编号，用来标示每一个分组和确认信息。（这样才知道需要发送哪个分组，收到了哪个分组的确认信息）
>
> ③超时计时器设置的时间应该略长于分组传送往返时间。





**（2）确认丢失和确认迟到**

- **确认丢失**  ：B再次收到该消息后采取以下两点措施：1.  丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。
- **确认迟到**   ：1.  A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。





**连续ARQ协议** 

**由于停止等待ARQ协议信道利用率太低**，所以需要使用连续ARQ协议来进行改善。这个协议会连续发送一组数据包，然后再等待这些数据包的ACK。

发送方采用流水线传输。流水线传输就是发送方可以连续发送多个分组，不必每发完一个分组就停下来等待对方确认。如下图所示：

![](../assets/1.30.png)



连续ARQ协议通常是结合滑动窗口协议来使用的，发送方需要维持一个发送窗口。



##### 4.1.4.3.2 滑动窗口

![](../assets/1.31.png)



上图是发送方维持的发送窗口，它的意义是：位于发送窗口内的5个分组都可以连续发送出去，而不需要等待对方的确认，这样就提高了信道利用率。 

连续ARQ协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。例如上面的图，当发送方收到第一个分组的确认，就把发送窗口向前移动一个分组的位置。如果原来已经发送了前5个分组，则现在可以发送窗口内的第6个分组。 

接收方一般都是采用**累积确认的方式**。也就是说接收方不必对收到的分组逐个发送确认。而是在收到几个分组后，对按序到达的最后一个分组发送确认。如果收到了这个分组确认信息，则表示到这个分组为止的所有分组都已经正确接收到了。 

累积确认的优点是容易实现，即使确认丢失也不必重传。但缺点是，不能正确的向发送方反映出接收方已经正确收到的所以分组的信息。比如发送方发送了前5个分组，而中间的第3个分组丢失了，这时候接收方只能对前2个发出确认。而不知道后面3个分组的下落，因此只能把后面的3个分组都重传一次，这种机制叫[Go](http://lib.csdn.net/base/go)-back-N（回退N），表示需要再退回来重传已发送过的N个分组。



##### 4.1.4.3.3流量控制

**TCP用滑动窗口进行流量控制。**

**TCP根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是流量控制。**

在TCP协议的报头信息当中，**有一个16位字段的窗口大小，窗口大小的内容实际上是接收端接收数据缓冲区的剩余大小**。如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。
![](../assets/1.17.png)

注：16位的窗口大小最大能表示65535个字节（64K），但是TCP的窗口大小最大并不是64K。在TCP首部中40个字节的选项中还包含了一个窗口扩大因子M，实际的窗口大小就是16为窗口字段的值左移M位。每移一位，扩大两倍。



##### 4.1.4.3.4 拥塞控制

TCP传输的过程中，发送端开始发送数据的时候，如果刚开始就发送大量的数据，那么就可能造成一些问题。

所以TCP引入了慢启动的机制，在开始发送数据时，先发送少量的数据探路。探清当前的网络状态如何，再决定多大的速度进行传输。这时候就引入一个叫做拥塞窗口的概念。

为了进行拥塞控制，TCP 发送方要维持一个 **拥塞窗口(cwnd)** 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。

TCP的拥塞控制采用了四种算法，即 **慢开始** 、 **拥塞避免** 、**快重传** 和 **快恢复**。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。

- **慢开始：**  由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，**cwnd加倍**。

- **拥塞避免：** 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的**cwnd加1.**

- **快重传： ** 快重传算法要求首先接收方收到一个失序的报文段后就立刻发出重复确认，而不要等待自己发送数据时才进行捎带确认。如果接收方收到了一个失序的报文，它会马上发送报告给发送方，告知它未收到报文，如果发送方收到重复的三个确认，则会立即重传确认所期待的下一个报文。 

- **快恢复：** 

  当A连续收到了三个确认M2的ACK，且M3超时事件还没发生。A就知道M3可能丢失了，这个时候A就不必等待M3设置的计时器到期了，而是快速重传M3。并且把ssthresh设置为MAX的一半，即ssthresh = MAX/2，但是这个时候并非把控制窗口N设置为1，而是让N = ssthresh，N在一个一个增长。 

![](../assets/1.18.png)

拥塞控制是TCP在传输时尽可能快的将数据传输，并且避免拥塞造成的一系列问题。是可靠性的保证，同时也是维护了传输的高效性。



## 4.2 UDP

[博客](https://blog.csdn.net/aa1928992772/article/details/85240358)

### 4.2.1 特点

UDP是传输层的协议，功能即为在IP的数据报服务之上增加了最基本的服务：复用和分用以及差错检测。



### 4.2.2 首部

UDP数据报分为**首部**和**用户数据部分**，整个UDP数据报作为IP数据报的数据部分封装在IP数据报中，UDP数据报文结构如图所示： 

![](../assets/1.19.png)

**UDP首部有8个字节，由4个字段构成，每个字段都是两个字节:**

1. 源端口： 源端口号，需要对方回信时选用，不需要时全部置0.

2. 目的端口：目的端口号，在终点交付报文的时候需要用到。

3. 长度：UDP的数据报的长度（包括首部和数据）其最小值为8（只有首部）

4. 校验和：检测UDP数据报在传输中是否有错，有错则丢弃。

   该字段是可选的，当源主机不想计算校验和，则直接令该字段全为0.

当传输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口，上交给应用进程。
如果接收方UDP发现收到的报文中的目的端口号不正确（不存在对应端口号的应用进程0,），就丢弃该报文，并由ICMP发送“端口不可达”差错报文给对方。



## 4.3 TCP和UDP的区别

![](../assets/1.20.jpg)

- TCP 是面向连接的，UDP 是面向无连接的
- UDP程序结构较简单
- TCP 是面向字节流的，UDP 是基于数据报的
- TCP 保证数据正确性，如果丢包就需要进行重传，UDP 可能丢包
- TCP 保证数据顺序，UDP 不保证
- TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
- TCP头部信息有20个字节，而UDP只有8个字节，UDP常用一次性传输比较少量数据的网络应用，如DNS,SNMP等，因为对于这些应用，若是采用TCP，为连接的创建，维护和拆除带来不小的开销。UDP也常用于多媒体应用（如IP电话，实时视频会议，流媒体等）数据的可靠传输对他们而言并不重要，TCP的拥塞控制会使他们有较大的延迟，也是不可容忍的。





# 5 应用层（Application Layer）

## 5.1 域名系统DNS

为什么不用域名来直接进行通信呢？

1. 因为IP地址是固定长度的，IPv4是32位，IPv6是128位，而域名是变长的，不便于计算机处理。
2. IP地址对于用户来说不方便记忆，但域名便于用户使用，例如www.baidu.com这是百度的域名。
   总结一点就是IP地址是面向主机的，而域名则是面向用户的。

### 5.1.1 域名结构

域名系统必须要保持唯一性。
为了达到唯一性的目的，因特网在命名的时候采用了层次结构的命名方法

**域名服务主要是基于UDP实现的，服务器的端口号为53。**

![](../assets/1.2.png)





### 5.1.2 域名分级

![](../assets/1.3.png)





### 5.1.3 域名服务器

域名需要由遍及全世界的域名服务器去解析，域名服务器实际上就是装有域名系统的主机。由高向低进行层次划分，可分为以下几大类：

- 根域名服务器：**每个根服务器与它的镜像服务器共享同一个  IP 地址**
- 顶级域名服务器
- 权限域名服务器
- 本地域名服务器：当一个主机发出DNS查询请求的时候，这个查询请求首先就是发给本地域名服务器的。

![](../assets/1.4.png)



### 5.1.4 域名解析过程

1. 主机先向本地域名服务器进行递归查询
2. 本地域名服务器向一个根域名服务器进行查询
3. 根域名服务器告诉本地域名服务器，下一次应该查询的顶级域名服务器的IP地址
4. 本地域名服务器向顶级域名服务器进行查询
5. 顶级域名服务器告诉本地域名服务器，下一步查询权限服务器的IP地址
6. 本地域名服务器向权限服务器进行查询
7. 权限服务器告诉本地域名服务器所查询的主机的IP地址
8. 本地域名服务器最后把查询结果告诉主机 





## 5.2 HTTP协议

[博客1](https://blog.csdn.net/a19881029/article/details/14002273)

[博客2](https://www.cnblogs.com/EricaMIN1987_IT/p/3837436.html)

##### 5.2.1 概念

协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。 

HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。 

**在Internet中所有的传输都是通过TCP/IP进行的**。HTTP协议作为TCP/IP模型中应用层的协议也不例外。HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。如下图所示：

 ![](../assets/1.10.png)

HTTP默认的端口号为80，HTTPS的端口号为443。 

##### 

##### 5.2.2 Connection: keep-alive

从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。

Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。

 

 

##### 5.2.3 工作流程

一次HTTP操作称为一个事务，其工作过程可分为四步：

1. 首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。
2. 建立连接后，客户机发送一个请求报文给服务器.
3. 服务器接到请求后，给予相应的响应报文。
4. 客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。

如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。

**HTTP是基于传输层的TCP协议，所以HTTP在开始传输之前，首先需要建立TCP连接，而TCP连接的过程需要所谓的三次握手和四次挥手。**

**在TCP三次握手之后，建立了TCP连接，此时HTTP就可以进行传输了。一个重要的概念是面向连接，既HTTP在传输完成之间并不断开TCP连接。在HTTP1.1中(通过Connection头设置)这是默认行为。**

 

##### 5.2.4 HTTP请求报文格式

HTTP请求报文主要由请求行、请求头部、请求正文3部分组成。

![](../assets/1.5.png)



**1.请求行**

| 组成部分(之间由空格分隔) | 内容                                                         |
| ------------------------ | ------------------------------------------------------------ |
| 请求方法                 | 包括GET、HEAD、PUT、POST、TRACE、OPTIONS、DELETE以及扩展方法<br>当然并不是所有的服务器都实现了所有的方法，部分方法即便支持，处于安全性的考虑也是不可用的 |
| URL                      | ---                                                          |
| 以及协议版本             | HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1           |





**2.请求头部**

请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔

常见请求头如下：

![](../assets/1.6.png)

请求头部的最后会有一个空行，表示请求头部结束，接下来为请求正文，这一行非常重要，必不可少 



**3.请求正文**

可选部分，比如GET请求就没有请求正文





##### 5.2.5 HTTP响应报文格式

HTTP响应报文主要由状态行、响应头部、响应正文3部分组成

![](../assets/1.7.png)

**1.状态行**

由3部分组成，分别为：协议版本，状态码，状态码描述，之间由空格分隔。

| 状态代码 | 含义                               |
| -------- | ---------------------------------- |
| 1xx      | HTTP/1.1向协议中引入了信息性状态码 |
| 2xx      | 表示成功                           |
| 3xx      | 指资源重定向                       |
| 4xx      | 指客户端请求出错                   |
| 5xx      | 指服务端出错                       |

这里列举几个常见的：

![](../assets/1.8.png)



**2.响应头部**

与请求头部类似，为响应报文添加了一些附加信息

常见响应头部如下：

![](../assets/1.9.png)





## 5.3 SMTP协议

[博客](https://blog.csdn.net/qq_35644234/article/details/68961603)

SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件   的规则，由它来控制信件的中转方式。 

**是一种TCP协议支持的提供可靠且有效电子邮件传输的应用层协议。** 



##### 5.3.1 过程

- 连接建立：SMTP客户和SMTP服务器首先要建立TCP连接。

> SMTP客户和SMTP服务器首先要建立TCP连接。
>
> 1. 从客户端使用熟知端口号25建立与服务器的TCP连接，SMTP服务器向该客户送回应答码220，并且还为客户端提供了服务器的域名
> 2. 客户端收到应答码后，发送HELO命令，启动客户端和服务器之间的SMTP会话。该客户端发送的HELO用来向服务器提供客户端的标识信息
> 3. 服务器端回应应答码250，通知客户端：请求建立邮件服务会话已经实现



- 报文发送
- 连接终止



##### 5.3.2 MIME协议

Multipurpose Internet Mail Extensions 

MIME试图在不改变SMTP协议和RFC822（邮件格式标准）的基础上，使得邮件可以传送任意二进制文件。另外，MIME 协议的数据格式也可以避免邮件内容在传输过程中发生信息丢失。MIME协议不是对RFC822邮件格式的升级和替代，而是基于RFC822邮件格式的扩展应用。

**改进措施：**

1. 新增了一些邮件头信息，用来协商MIME的一些参数。
2. 定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。
3. 定义了传送编码，从而可以传送任意二进制文件。



## 5.4 FTP-文件传输协议

工作在TCP/IP模型的应用层，**基于的传输协议是TCP**，FTP客户端和服务器之间的连接是可靠的，面向连接的，为数据的传输提供了可靠的保证。 

与一般的 C/S 应用不同点在于一般的C/S 应用程序一般只会建立一个 Socket 连接，这个连接同时处理服务器端和客户端的连接命令和数据传输。**而FTP协议中将命令与数据分开传送的方法提高了效率。**

 FTP 使用 2 个端口，控制  Socket 用来传送命令，数据 Socket 是用于传送数据。

每一个 FTP 命令发送之后，FTP  服务器都会返回一个字符串，其中包括一个响应代码和一些说明信息。其中的返回码主要是用于判断命令是否被成功执行了。



## 5.5 TFTP-简单文件传输协议

[博客](https://www.cnblogs.com/chusiyong/p/11389442.html)

Trivial File Transfer Protocol 

TFTP是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为69。

**它基于UDP协议而实现**，协议设计的时候是进行小文件传输的。因此它不具备通常的FTP的许多功能，它只能从文件服务器上获得或写入文件，不能列出目录，不进行认证，它传输8位数据。常用于嵌入式设备开发中。 



##### 5.5.1 传输模式

文件在传输的过程中需要指明数据的表示方式：

| 模式名称 | 模式含义                          | 说明       |
| -------- | --------------------------------- | ---------- |
| netascii | 文本传输模式，按照一个字节8位解析 | 文本模式   |
| octet    | 二进制模式，数据无需解析          | 二进制模式 |
| mail     | 已过时，不使用                    | 已过时     |

##### 5.5.2 报文类型

TFTP共定义了五种类型的包格式，格式的区分由包数据前两个字节的Opcode字段区分，分别是：

- 读文件请求包
- 写文件请求包
- 文件数据包
- 回应包：ACK
- 错误信息包



##### 5.5.3 协议模式

由于 TFTP 是基于 UDP 协议的，而 UDP 数据包本身就不是很安全， 因此，为了能够让发送端知道接收端已经接收到了发送端发来的数据包，接收端对接收到的每一个数据包都进行确认。 



##### 5.5.4 TFTP协议的缺陷

1. 传输效率低
2. 对于超时机制没有明确说明
3. 每包长度固定为512字节，不灵活





## 5.6 远程登录（Telnet）

[博客](https://blog.csdn.net/sundacheng1989/article/details/51005050)

Telnet最常见的是对服务器的远程登录。 



##### 5.6.1 工作流程

当你用Telnet登录进入远程计算机系统时，你事实上启动了两个程序，一个 叫Telnet客户程序，它运行在你的本地机上(端口一般为23)；另一个叫Telnet服务器程序，它运 行在你要登录的远程计算机上。本地机上的客户程序要完成如下功能： 

1. 建立与服务器的TCP 联接； 
2. 从键盘上接收你输入的字符； 
3. 把你输入的字符串变成标准格式并送给远程服务器； 
4. 从远程服务器接收输出的信息； 
5. 把该信息显示在你的屏幕上。 



##### 5.6.2 工作原理

telnet是**以TCP为基础与服务器进行通信**，所以它的功能远不止远程登录服务器（远程操纵服务器）。不管是什么协议，如果它基于 tcp/ip，那么你使用 TcpClient（或者 Socket）连接它，然后发点信息，依然能连通。Telnet可以看作是一种TCP的连接工具。 

> Http是通过TCP连接传输字符，但是数据格式是HTTP协议规定的格式。简单来说，所谓的HTTP协议，FTP协议，SMTP协议，就是各自规定了以什么样的数据包方式在网络上通过TCP管道传输数据。 

比如，telnet可以和SMTP进行通信：因为SMTP也是基于tcp的

![](../assets/1.29.png)

如上图所示，这是在一台Linux机器上向互联网中的一台邮件服务器发送邮件。





## 5.7 SNMP-简单网络管理协议

[博客](https://blog.csdn.net/qq_28657577/article/details/82257343)

##### 5.7.1 什么是SNMP

SNMP是简单的网络管理协议，它不是一个软件，而是用于网络管理的**一套规则**。利用SNMP，**一个管理工作站可以远程管理所有支持这种协议的网络设备，包括监视网络状态、修改网络设备配置、接收网络事件警告**等。



##### 5.7.2 技术要点

（1）**基于TCP/IP互联网的标准协议，传输层协议一般用UDP**

（2）自动化网络管理。网络管理员可以利用SNMP平台在网络上的节点检索信息、修改信息、发现故障、完成故障诊断、进行容量规划和生成报告

（3）屏蔽不同设备的物理差异，实现对不同厂商产品的自动化管理。SNMP只提供最基本得功能集，使得管理任务与被管理设备的物理特征和实际网络类型相对独立，从而实现对不同厂商设备的管理

（4）简单的请求-应答方式和主动通告方式相结合，并有超时和重传机制

（5）报文种类少，报文格式简单，方便解析，易于实现

（6）SNMPv3版本提供了认证和加密安全机制，以及基于用户和视图的访问控制功能，增强了安全性

 

##### 5.7.4 SNMP的网络架构

SNMP网络架构由三部分组成：NMS（网络管理站）、Agent（代理）、MIB（管理信息库）

1. NMS（网络管理站）

NMS是网络中的管理者，是一个利用SNMP协议对网络设备进行管理和监视的系统。

 

2.Agent

Agent是网络设备中的一个应用模块，用于维护被管理设备的信息数据，并响应NMS的请求，把管理数据汇报给发送请求的NMS。

 

3.MIB

任何一个被管理的资源都表示成一个对象，称为被管理的对象。MIB就是被管理对象的集合。它定义了被管理对象的一系列的属性：对象的名称、对象的访问权限和对象的数据类型等。每个Agent都有自己的MIB。MIB也可以看做是NMS和Agent之间的一个接口，通过这个接口，NMS可以对Agent中的每一个被管理对象进行读/写操作，从而达到管理和监控设备的目的。

 

NMS、Agent和MIB之间的关系如图所示：

 ![img](https://img-blog.csdn.net/20131027023213796?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2htaWx5X2NtbDA2MDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

 

MIB的结构：

MIB是以树状结构进行存储的，树的节点表示被管理对象，它可以用从根开始的一条路径唯一地识别，这条路径就称为OID。

如图所示，管理对象system可以用一串数字{1.3.6.1.2.1.1}唯一标识，这串数字就是system的OID。

 ![img](https://img-blog.csdn.net/20131027022423968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2htaWx5X2NtbDA2MDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

 



[超级好的一篇博客，总结了ip/tcp协议簇](https://developer.51cto.com/art/201906/597961.htm#topx)


