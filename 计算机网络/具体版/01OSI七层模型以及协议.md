[知识点在这里](https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C)

# 1 OSI(七层模型)

![](./assets/1.28.jpg)



OSI（Open System Interconnection，开放系统互连）七层网络模型称为开放式系统互联参考模型 ，是一个逻辑上的定义，一个规范，它把网络从逻辑上分为了7层。每一层都有相关、相对应的物理设备，比如路由器，交换机。OSI 七层模型是一种框架性的设计方法 ，建立七层模型的主要目的是为解决异种网络互连时所遇到的兼容性问题，其最主要的功能使就是帮助不同类型的主机实现数据传输。它的最大优点是将服务、接口和协议这三个概念明确地区分开来，通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯。

 

**模型优点**

建立七层模型的主要目的是为解决异种网络互连时所遇到的兼容性问题。它的最大优点是将服务、接口和协议这三个概念明确地区分开来：服务说明某一层为上一层提供一些什么功能，接口说明上一层如何使用下层的服务，而协议涉及如何实现本层的服务；这样各层之间具有很强的独立性，互连网络中各实体采用什么样的协议是没有限制的，只要向上提供相同的服务并且不改变相邻层的接口就可以了。网络七层的划分也是为了使网络的不同功能模块（不同层次）分担起不同的职责，从而带来如下好处： 　　

- 减轻问题的复杂程度，一旦网络发生故障，可迅速定位故障所处层次，便于查找和纠错； 　　
- 在各层分别定义标准接口，使具备相同对等层的不同网络设备能实现互操作，各层之间则相对独立，一种高层协议可放在多种低层协议上运行； 　　
-  能有效刺激网络技术革新，因为每次更新都可以在小范围内进行，不需对整个网络动大手术； 　　
- 便于研究和教学。



# 2 概览

| OSI七层模型 | 功能                                                         | 对应的网络协议      | TCP/IP四层概念模型 |
| ----------- | ------------------------------------------------------------ | ------------------- | ------------------ |
| 应用层      | 是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。 | HTTP、TFTP, FTP     | 应用层             |
| 表示层      | 可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 | telnet、SNMP        |                    |
| 会话层      | 通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名） | SMTP, DNS           |                    |
| 传输层      | 定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（[用户数据报协议](http://baike.baidu.com/view/468464.htm)，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。 | TCP, UDP            | 传输层             |
| 网络层      | 在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。 | IP, ICMP, ARP, RARP | 网络层             |
| 数据链路层  | 定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。 |                     | 数据链路层         |
| 物理层      | 主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 |                     |                    |





# 3 网络层（Network Layer）

## 3.1 IP协议

[博客](https://blog.csdn.net/ever_peng/article/details/80054212)

我们都已经知道，Internet是由无数台计算机互相连接而成的。而我们要确认网络上的每一台计算机，靠的就是能唯一标识该计算机的网络地址，这个地址就叫做IP（Internet Protocol的简写）地址，即用Internet协议语言表示的地址。  



##### 3.1.1 IP协议功能

（1）寻址和路由；（根据对方的IP地址，寻找最佳路径传输信息）；

（2）传递服务：

① 不可靠（IP协议只是尽自己最大努力去传输数据包），可靠性由上层协议提供（TCP协议）；	② 无连接（事先不建立会话），不维护任何关于后续数据报的信息；

（3）数据包的分片和重组。



##### 3.1.2 子网掩码

子网掩码(subnet mask)又叫网络掩码，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。 



##### 3.1.3  IP报文格式

![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.21.png)

**版本号：**4个bit，用来标识IP版本号。这个4位字段的值设置为二进制的0100表示IPv4，设置为0110表示IPv6。目前使用的IP协议版本号是4。

**首部长度**：4个bit。标识包括选项在内的IP头部字段的长度。

**服务类型**：8个bit。服务类型字段被划分成两个子字段：3bit的优先级字段和4bit TOS字段，最后一位置为0。4bit的TOS分别代表：最小时延，最大吞吐量，最高可靠性和最小花费。4bit中只能将其中一个bit位置1。如果4个bit均为0，则代表一般服务。

**总长度：**16个bit。接收者用IP数据报总长度减去IP报头长度就可以确定数据包数据有效负荷的大小。IP数据报最长可达65535字节。

**标识**：16个bit。唯一的标识主机发送的每一份数据报。接收方根据分片中的标识字段是否相同来判断这些分片是否是同一个数据报的分片，从而进行分片的重组。通常每发送一份报文它的值就会加1。

**标志**：3个bit。用于标识数据报是否分片。第1位没有使用，第2位是不分段（DF）位。当DF位被设置为1时，表示路由器不能对数据包进行分段处理。如果数据包由于不能分段而未能被转发，那么路由器将丢弃该数据包并向源发送ICMP不可达。第3位是分段（MF）位。当路由器对数据包进行分段时，除了最后一个分段的MF位被设置为0外，其他的分段的MF位均设置为1，以便接收者直到收到MF位为0的分片为止。

**片偏移**：13个bit。在接收方进行数据报重组时用来标识分片的顺序。用于指明分段起始点相对于报头起始点的偏移量。由于分段到达时可能错序，所以位偏移字段可以使接收者按照正确的顺序重组数据包。当数据包的长度超过它所要去的那个数据链路的MTU时，路由器要将它分片。数据包中的数据将被分成小片，每一片被封装在独立的数据包中。接收端使用标识符，分段偏移以及标记域的MF位来进行重组。

**生存时间**:8个bit。TTL域防止丢失的数据包在无休止的传播。该域包含一个8位整数，此数由产生数据包的主机设定。TTL值设置了数据报可以经过的最多的路由器数。TTL的初始值由源主机设置（通常为32或64），每经过一个处理它的路由器，TTL值减1。如果一台路由器将TTL减至0，它将丢弃该数据包并发送一个ICMP超时消息给数据包的源地址。

**协议**：8个bit。用来标识是哪个协议向IP传送数据。ICMP为1，IGMP为2，TCP为6，UDP为17，GRE为47，ESP为50。

**首部检验和**：根据IP首部计算的校验和码。

**源地址**：IP报文发送端的IP地址

**目的地址**：IP报文接收端的IP地址

**选项：**是数据报中的一个可变长的可选信息。选项字段以32bit为界，不足时插入值为0的填充字节。保证IP首部始终是32bit的整数倍。

##### 3.1.4 IP分片偏移

**分片原因**

以太网的MTU是1500。如果IP层有数据包要传，而且数据包的长度超过了MTU，那么IP层就要对数据包进行分片（fragmentation）操作，使每一片的长度都小于或等于MTU。我们假设要传输一个UDP数据包，以太网的MTU为1500字节，一般IP首部为20字节，UDP首部为8字节，数据的净荷（payload）部分预留是1500-20-8=1472字节。如果数据部分大于1472字节，就会出现分片现象。

**不同传输层协议的分片**

（1）TCP协议

对于TCP协议来说尽量避免分片，因为当在IP层进行了分片后，如果其中的某片数据丢失，则需对整个数据报进行重传。因为IP层本身没有超时重传机制，当来自TCP报文段的某一片丢失后，TCP在超时后重发整个TCP报文段，该报文段对应于一份IP数据报，没有办法只重传数据报中的一个数据报片。

TCP协议可以避免分片，避免的机制是首先，TCP在建立连接时会进行3次握手，而在这3次握手中，客户端和服务端通常会协商一个值，那就是MSS（最长报文大小），用来表示本段所能接收的最大长度的报文段。MSS=MTU-TCP首部大小-IP首部大小，MTU值通过查询链路层得知。

当两端确认好MSS后进行通信，TCP层往IP层传输数据时，如果TCP层缓冲区的大小大于MSS，那么TCP层都会将其中的数据分组进行传输，这样就避免了在IP层进行分片。

（2）UDP协议

对于UDP而言，由于UDP是不需要保证可靠性的，没有超时和重传机制，这使得UDP很容易导致IP分片。

UDP协议分片会根据IP报文字段中的标识字段、标志字段、片偏移字段来解决。

 ![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.22.png)

对于每份IP数据报来说，其16位标识字段都包含一个唯一值。在数据报被分片时，这个值同时被复制到每个片中。用来识别分片的数据是否为同一个数据报文。

在IP首部中，我们看到有一个占了3位的标志字段，其中第1位是R作为保留字段未用；第2位分段是DF用来表示一个数据报是否允许在IP层被分片，DF=0时允许分片，DF=1时不允许分片；而第3位是MF更多分片字段，则是当数据报被分片时，让接收端知道在什么时候完成所有的分片组装，除了最后一片外，其他每个组成数据报的片都要把该比特置1。

而如果将其中的分段标志比特位置1，表示不允许IP层对数据报进行分片。例如当路由器收到一份需要分片的数据报，而在IP首部又设置了不分片（DF）的标志比特，路由器会丢弃数据报并发送一个ICMP差错报文（“需要进行分片但设置了不分片比特”）。

IP首部的13位片偏移字段表示IP分片再整个数据流中的位置，第一个数据报分片的偏移量置为0，而后续的分片偏移量则是根据网络的MTU大小设置，且必须为8的整数倍。



**分片字段**

 ![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.23.png)

以上图中我们看到把一个报文长度为3800字节的报文分片为三个。他们每一个分片都会含有一个标识（IP地址 + 标识），到达目的地要对其所有的分片进行重新组装；

片偏移计算过程；首部分大体的内容是一样，因为都属于同一个数据报文！



##### 3.1.5 IP报文重组

IP报文分片后进行重组，只能在目标主机进行重组。

IP报文分片重组时，采用了一组重组定时器，片重组的控制主要根据数据首部中的标识、标志、偏移字段进行重组。

分片重组策略如下：

（1）第一个分片的偏移值时0

（2）将第一个分片携带的数据长度除以8，结果就是第二个分片的偏移值

（3）将第一个和第二个分片携带数据的总长度除以8，结果就是第二个分片的偏移值

（4）继续以上过程。直到之后分片的MF标志位为0



##### 3.1.6 IP报文校验

**IP报文校验和计算方式**

（1）为了计算一份数据报的IP检验和，首先需要把检验和字段置为0

（2）对首部中每个16bit进行二进制反码求和（整个首部看成是由一串16bit的字组成）

PS：路由器收到IP报文，然后转发之后，是需要对TTL（Time to Live）字段减一，那么这样的话IP报文校验和数值也需要进行相应改变

**IP报文不对数据校验原因**

上层传输层是端到端的协议，进行端到端的校验比进行点到点的校验开销小。

IP报文对IP首部校验原因**

IP首部属于IP层协议的内容，上层协议无法处理。

IP首部的部分字段在点到点的传递过程中是不断变化的，只能在每个中间点重新形成校验数据，在相邻点完成校验。



## 3.2 ICMP- Internet控制信息协议

Internet Control Message Protocol 

一个新搭建好的网络，往往需要先进行一个简单的测试，来验证网络是否畅通；但是IP协议并不提供可靠传输。如果丢包了，IP协议并不能通知传输层是否丢包以及丢包的原因。   所以我们就需要一种协议来完成这样的功能–ICMP协议。 



##### 3.2.1 功能

ICMP协议的功能主要有：   

1. 确认IP包是否成功到达目标地址   
2. 通知在发送过程中IP包被丢弃的原因   如下图所示：  

![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.24.png)



注意：  ICMP只能搭配IPv4使用，如果是IPv6的情况下, 需要是用ICMPv6 



##### 3.2.2 报文格式

CMP报文包含在IP数据报中，IP报头在ICMP报文的最前面。一个ICMP报文包括IP报头（至少20字节）、ICMP报头（至少八字节）和ICMP报文（属于ICMP报文的数据部分）。当IP报头中的协议字段值为1时，就说明这是一个ICMP报文。ICMP报头如下图所示。 

![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.25.png)

字段说明：

| 类型   | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| 类型   | 占一字节，标识ICMP报文的类型，从类型值来看ICMP报文可以分为两大类。第一类是取值为1~127的差错报文，第2类是取值128以上的信息报文 |
| 代码   | 占一字节，标识对应ICMP报文的代码。它与类型字段一起共同标识了ICMP报文的详细类型 |
| 校验和 | 这是对包括ICMP报文数据部分在内的整个ICMP数据报的校验和，以检验报文在传输过程中是否出现了差错（其计算方法与在我们介绍IP报头中的校验和计算方法是一样的） |



##### 3.2.3 报文类型

ICMP大概分为两类报文：  

一类是通知出错原因 ；一类是用于诊断查询  

| 类型（十进制） | 内容             |
| -------------- | ---------------- |
| 0              | 回送应答         |
| 3              | 目标不可达       |
| 4              | 原点抑制         |
| 5              | 重定向或改变路由 |
| 8              | 回送请求         |
| 9              | 路由器公告       |
| 10             | 路由器请求       |
| 11             | 超时             |
| 17             | 地址子网请求     |
| 18             | 地址子网应答     |



##### 3.2.4 时间戳请求

时间戳请求报文（类型值字段13）和时间戳应答报文（类型值字段14）用于测试两台主机之间数据报来回一次的传输时间。 
 传输时，主机填充原始时间戳，接受方收到请求后填充接受时间戳后以类型值字段14的报文格式返回，发送方计算这个时间差。



##### 3.2.5 常见应用-ping

我们用的ping操作中就包括了相应请求（类型字段值为8）和应答（类型字段值为0）ICMP报文。

**过程：**
一台主机向一个节点发送一个类型字段值为8的ICMP报文，如果途中没有异常（如果没有被路由丢弃，目标不回应ICMP或者传输失败），则目标返回类型字段值为0的ICMP报文，说明这台主机存在。



**功能**：

（1）能验证网络的连通性   

（2）会统计响应时间和TTL(IP包中的Time To Live，生存周期)



**问题：**

telnet是23端口，ssh是22端口，那么ping是什么端口?    答：ping命令是基于ICMP，是在网络层。   而端口号，是传输层的内容。所以在ICMP中根本就不关注端口号这样的信息。  





##### 3.2.6 traceroute

traceroute也是基于ICMP协议实现的。   

**功能：**   打印出可执行程序主机，一直到目标主机之前经历多少路由器。   

**工作原理  ：**

是利用ICMP差错控制报文中的TTL超时会回向源点发送一个时间超时报文。例如A 主机 traceroute  B主机，A会封装一些分组，这些分组很特殊，例如第一个分组的TTL设置为1 ，第二个分组的TTL设置为2  以此类推.......当第一个分组到达第一个路由器时，发现TTL变成了0就会给源主机发送一个时间超时报文，这也就知道了这个分组所经过的一个路由器，同理可得。 当最后一个分组到达B主机时。收集每个时间超时的报文中的IP 就获得了A主机到B主机的路径。 



举例如下：  

![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.26.png)

**域名可以通过DNS解析为IP地址**







## 3.3 ARP-地址解析协议

**地址解析协议（Address Resolution Protocol）** 

##### 3.3.1 功能

我们都知道局域网里面通信，都是靠**MAC地址**来通信的。ARP简单说，就是用来把IP地址转换成MAC地址，就是某个去往目的IP地址翻译成MAC地址。



##### 3.3.2 原理

示例：

![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.27.jpg)

电脑从上层往下封装，到了二层，要封装帧头部时，就需要把目的mac地址封装上，形成完整的二层头部后，就可以发送出去了。 

现在的问题就是，电脑如何知道对方的MAC地址？ 

这时候，计算机A就执行ARP程序，发送一个ARP请求报文的广播包，这样，交换机收到这个报文，看到目的mac地址是全F就广播。

数据包关键字如下：

| 目的MAC地址 | ffff.ffff.ffff.ffff |
| ----------- | ------------------- |
| 源mac地址   | 1111.1111.1111.1111 |
| 类型        | 0x0806              |
| source IP   | 1.1.1.1             |
| target IP   | 1.1.1.2             |

所有的计算机收到这个广播包，会进行更深入的解析，看到里面的target IP 是1.1.1.2,  与自己的IP地址进行对比，发现不一样，就丢弃。发现一样，就回应ARP报文。 

计算机A收到回应的这个报文后，就将计算机E的mac地址记录下来，存在计算机A的一个数据库，叫做ARP缓存表。下次通信时，如果缓存未超时，就可以直接使用了。如果超时了，就再次进行arp请求广播了。 



##### 3.3.3 ARP攻击

ARP协议的基本功能就是通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的进行。 基于ARP协议的这一工作特性，黑客向对方计算机不断发送有欺诈性质的ARP数据包，数据包内包含有与当前设备重复的Mac地址，使对方在回应报文时，由于简单的地址重复错误而导致不能进行正常的网络通信。

一般情况下，受到ARP攻击的计算机会出现两种现象：
1)不断弹出“本机的XXX段硬件地址与网络中的XXX段地址冲突”的对话框。
2) 计算机不能正常上网，出现网络中断的症状。

因为这种攻击是利用ARP请求报文进行“欺骗”的，所以防火墙会误以为是正常的请求数据包，不予拦截。因此普通的防火墙很难抵挡这种攻击。 



##### 3.3.4 ARP代理

用于跨网段访问。

**原理：**

当出现跨网段的ARP请求时，路由器将自己的MAC返回给发送ARP广播请求发送者，实现MAC地址代理（善意的欺骗），最终使得主机能够通信。 

![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.28.png)

图中R1和R3处于不同的局域网，R1和R3在相互通信时，R1先发送了一个ARP广播数据包，请求R3的mac地址，但是由于R1是12.1.1.0网段，而R3是13.1.1.0网段，R1和R3之间是跨网段访问的，也就是说R1的ARP请求会被R2拦截到，然后R2会封装自己的mac地址为目的地址发送一个ARP回应数据报给R1（善意的欺骗），然后R2就会代替R1去访问R3。 







## 3.4 RARP-反向地址解析协议

Reverse Address Resolution Protocol 

**作用：**完成硬件地址到IP地址的映射，主要用于无盘工作站，因为无盘工作站配置的IP地址不能保存。

**工作流程：**在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。



# 4 传输层（Transport Layer）

**运输层主要使用以下两种协议:**

1. **传输控制协议 TCP**（Transmission Control Protocol）--提供**面向连接**的，**可靠的**数据传输服务。
2. **用户数据协议 UDP**（User Datagram Protocol）--提供**无连接**的，尽最大努力的数据传输服务（**不保证数据传输的可靠性**）。



## 4.1 TCP

[博客1](https://blog.csdn.net/qq_38950316/article/details/81087809)

[博客2](https://www.cnblogs.com/Andya/p/7272462.html)

### 4.1.1 首部

![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.11.png)



1. **源端口和目的端口**，各占2个字节，分别写入源端口和目的端口；
2. **序号seq**，占4个字节，数据是每个字节一个序号 。就是告诉接收方：我发送的数据是从seq开始的。 **当发送syn标记时将消耗一个序号；** **对于要发送的数据的第一个序号而言这个序号是通过一个算法计算得到一个初始序号（ISN）加1** 
3. **确认号ack**，占4个字节，就是告诉接收方：我希望下次收到对端发过来的seq序号值。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701； 
4. **数据偏移**，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；
5. **保留**，占6位，保留今后使用，但目前应都位0；
6. **紧急URG**，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；
7. **确认ACK**，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；
8. **推送PSH**，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；
9. **复位RST，**当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；
10. **同步SYN，**在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；
11. **终止FIN**，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；
12. **窗口**，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；
13. **检验和**，占2字节，校验首部和数据这两部分；
14. **紧急指针**，占2字节，指出本报文段中的紧急数据的字节数；
15. **选项，**长度可变，定义一些其他的可选的参数。



### 4.1.2 三次握手





![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.12.png)

而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。 

最初两端的TCP进程都处于CLOSED关闭状态，A主动打开连接，而B被动打开连接。（**A、B关闭状态CLOSED**——**B收听状态LISTEN——A同步已发送状态SYN-SENT——B同步收到状态SYN-RCVD——A、B连接已建立状态ESTABLISHED**）



**总结三次握手过程：**

- **第一次握手**：起初两端都处于CLOSED关闭状态，Client将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给Server，Client进入SYN-SENT状态，等待Server确认；
- **第二次握手**：Server收到数据包后由标志位SYN=1得知Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给Client以确认连接请求，Server进入SYN-RCVD状态，此时操作系统为该TCP连接分配TCP缓存和变量；
- **第三次握手**：Client收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并且此时操作系统为该TCP连接分配TCP缓存和变量，并将该数据包发送给Server，Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client和Server就可以开始传输数据。

|                          发送                           |
| :-----------------------------------------------------: |
|       A        SYN=1,seq=x(随机产生)   ➡        B       |
| A        SYN=1,ACK=1,ack=x+1,seq=y(随机产生) ⬅        B |
|           A        ACK=1,ack=y+1  ➡         B           |



​  

**为什么A还要发送一次确认呢？可以二次握手吗？**

　　答：**主要为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误**。如A发出连接请求，但因连接请求报文丢失而未收到确认，于是A再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，A工发出了两个连接请求报文段，其中第一个丢失，第二个到达了B，但是第一个丢失的报文段只是在**某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达B**，此时B误认为A又发出一次新的连接请求，于是就向A发出确认报文段，同意建立连接，不采用三次握手，只要B发出确认，就建立新的连接了，此时A不理睬B的确认且不发送数据，则B一致等待A发送数据，浪费资源。



**Server端易受到SYN攻击？**

服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击，SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。

防范SYN攻击措施：降低主机的等待时间使主机尽快的释放半连接的占用，短时间受到某IP的重复SYN则丢弃后续请求。



### 4.1.3 四次挥手

![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.14.png)

|                         发送                          |
| :---------------------------------------------------: |
|           A        SYN=1,seq=u   ➡        B           |
|        A        ACK=1,ack=u+1,seq=v ⬅        B        |
|      A       SYN=1, ACK=1,seq=w,ack=u+1⬅       B      |
| A       ACK=1,seq=u+1,ack=w+1,等待2MSL后关闭➡       B |





数据传输结束后，通信的双方都可释放连接，A和B都处于ESTABLISHED状态。（**A、B连接建立状态ESTABLISHED**——**A终止等待1状态FIN-WAIT-1**——**B关闭等待状态CLOSE-WAIT**——**A终止等待2状态FIN-WAIT-2**——**B最后确认状态LAST-ACK**——**A时间等待状态TIME-WAIT**——**B、A关闭状态CLOSED**） 



1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2. 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
3. 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
5. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
6. ​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。





**为什么A在TIME-WAIT状态必须等待2MSL的时间？**

MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 

答：两个理由：

1）保证A发送的最后一个ACK报文段能够到达B。

2）防止“已失效的连接请求报文段”出现在本连接中。

- 1）这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，B超时重传FIN+ACK报文段，而A能在2MSL时间内收到这个重传的FIN+ACK报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到CLOSED状态，若A在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则B无法正常进入到CLOSED状态。
- 2）A在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。

**为什么连接的时候是三次握手，关闭的时候却是四次握手？**

答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

**为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？**

答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。



### 4.1.4 TCP 协议如何保证可靠传输

[博客](https://blog.csdn.net/liuchenxia8/article/details/80428157)

TCP协议传输的特点主要就是面向字节流、传输可靠、面向连接。

**TCP协议通过使用连续ARQ协议和滑动窗口协议，来保证数据传输的正确性，从而提供可靠的传输。** 

TCP协议保证数据传输可靠性的方式主要有：

- 校验和
- 序列号
- 确认应答
- 超时重传
- 连接管理
- 流量控制
- 拥塞控制

**1.校验和**

计算方式：在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和。
发送方：在发送数据之前计算检验和，并进行校验和的填充。
接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。

![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.15.png)

注意：如果接收方比对校验和与发送方不一致，那么数据一定传输有误。但是如果接收方比对校验和与发送方一致，数据不一定传输成功。



**2.确认应答与序列号**

序列号：TCP传输时将每个字节的数据都进行了编号，这就是序列号。
确认应答：TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。

![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.16.png)

序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。



**3.超时重传**

在进行TCP传输时，由于确认应答与序列号机制，也就是说发送方发送一部分数据后，都会等待接收方发送的ACK报文，并解析ACK报文，判断数据是否传输成功。如果发送方发送完数据后，迟迟没有等到接收方的ACK报文，这该怎么办呢？而没有收到ACK报文的原因可能是什么呢？

首先，发送方没有介绍到响应的ACK报文原因可能有两点：

- 数据在传输过程中由于网络原因等直接全体丢包，接收方根本没有接收到。
- 接收方接收到了响应的数据，但是发送的ACK报文响应却由于网络原因丢包了。

TCP在解决这个问题的时候引入了一个新的机制，叫做超时重传机制。简单理解就是发送方在发送完数据后等待一个时间，时间到达没有接收到ACK报文，那么对刚才发送的数据进行重新发送。如果是刚才第一个原因，接收方收到二次重发的数据后，便进行ACK应答。如果是第二个原因，接收方发现接收的数据已存在（判断存在的根据就是序列号，所以上面说序列号还有去除重复数据的作用），那么直接丢弃，仍旧发送ACK应答。

那么发送方发送完毕后等待的时间是多少呢？如果这个等待的时间过长，那么会影响TCP传输的整体效率，如果等待时间过短，又会导致频繁的发送重复的包。如何权衡？

由于TCP传输时保证能够在任何环境下都有一个高性能的通信，因此这个最大超时时间（也就是等待的时间）是动态计算的。

> 在Linux中（BSD Unix和Windows下也是这样）超时以500ms为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。重发一次后，仍未响应，那么等待2*500ms的时间后，再次重传。等待4*500ms的时间继续重传。以一个指数的形式增长。累计到一定的重传次数，TCP就认为网络或者对端出现异常，强制关闭连接。



**4.连接管理**

连接管理就是三次握手与四次挥手的过程，在前面详细讲过这个过程，这里不再赘述。保证可靠的连接，是保证可靠性的前提。



##### 4.1.4.1 ARQ协议

[博客](https://www.cnblogs.com/blythe/articles/7348812.html)

T**CP协议通过使用连续ARQ协议和滑动窗口协议，来保证数据传输的正确性，从而提供可靠的传输。** 

**简介：**

ARQ协议，即自动重传请求，是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用**确认**和**超时**这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。

ARQ包括停止等待ARQ协议和连续ARQ协议，拥有错误检测、正面确认、超时重传和负面确认及重传等机制。 



**停止等待ARQ协议** ：

TCP 连接是全双工的连接，也就是说在通信的时候，双方既是发送方，也是接收方。

 **（1）超时重传**

如果A发送的过程中出现差错，B在接收M1时检测出了差错，就丢弃M1，又或者A传送的过程中分组丢失了，以上这两种情况下，B不会发送任何信息。 

既然说它是可靠传输协议，那自然有它可靠的方法：如果发生以上的情况，**A只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，所以它会重传刚刚的发送过的分组**。

超时重传的原理也很简单：发送方发送完一个分组后，就会设置一个**超时计时器**，如果超时计时器到期之前没有收到接收方发来的确认信息，则会重发刚发送过的分组；如果收到确认信息，则撤销该超时计时器。



> 注意：
>
> ①既然发送方发送的分组可能丢失或者有差错，可能需要重传，那么它必须暂时保留已发送的分组副本，只有收到确认后，才清除这个副本。
>
> ②分组和确认分组信息都应该有各自的编号，用来标示每一个分组和确认信息。（这样才知道需要发送哪个分组，收到了哪个分组的确认信息）
>
> ③超时计时器设置的时间应该略长于分组传送往返时间。





**（2）确认丢失和确认迟到**

- **确认丢失**  ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1.  丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。
- **确认迟到**   ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1.  A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。





**连续ARQ协议** 

**由于停止等待ARQ协议信道利用率太低**，所以需要使用连续ARQ协议来进行改善。这个协议会连续发送一组数据包，然后再等待这些数据包的ACK。

发送方采用流水线传输。流水线传输就是发送方可以连续发送多个分组，不必每发完一个分组就停下来等待对方确认。如下图所示：

![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.30.png)



连续ARQ协议通常是结合滑动窗口协议来使用的，发送方需要维持一个发送窗口。



##### 4.1.4.2 滑动窗口

![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.31.png)



上图是发送方维持的发送窗口，它的意义是：位于发送窗口内的5个分组都可以连续发送出去，而不需要等待对方的确认，这样就提高了信道利用率。 

连续ARQ协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。例如上面的图，当发送方收到第一个分组的确认，就把发送窗口向前移动一个分组的位置。如果原来已经发送了前5个分组，则现在可以发送窗口内的第6个分组。 

接收方一般都是采用**累积确认的方式**。也就是说接收方不必对收到的分组逐个发送确认。而是在收到几个分组后，对按序到达的最后一个分组发送确认。如果收到了这个分组确认信息，则表示到这个分组为止的所有分组都已经正确接收到了。 

累积确认的优点是容易实现，即使确认丢失也不必重传。但缺点是，不能正确的向发送方反映出接收方已经正确收到的所以分组的信息。比如发送方发送了前5个分组，而中间的第3个分组丢失了，这时候接收方只能对前2个发出确认。而不知道后面3个分组的下落，因此只能把后面的3个分组都重传一次，这种机制叫[Go](http://lib.csdn.net/base/go)-back-N（回退N），表示需要再退回来重传已发送过的N个分组。



##### 4.1.4.3流量控制

**TCP用滑动窗口进行流量控制。**

接收端在接收到数据后，对其进行处理。如果发送端的发送速度太快，导致接收端的结束缓冲区很快的填充满了。此时如果发送端仍旧发送数据，那么接下来发送的数据都会丢包，继而导致丢包的一系列连锁反应，超时重传呀什么的。而TCP根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是流量控制。

在TCP协议的报头信息当中，有一个16位字段的窗口大小，窗口大小的内容实际上是接收端接收数据缓冲区的剩余大小。这个数字越大，证明接收端接收缓冲区的剩余空间越大，网络的吞吐量越大。接收端会在确认应答发送ACK报文时，将自己的即时窗口大小填入，并跟随ACK报文一起发送过去。而发送方根据ACK报文里的窗口大小的值的改变进而改变自己的发送速度。如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。
![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.17.png)

注：16位的窗口大小最大能表示65535个字节（64K），但是TCP的窗口大小最大并不是64K。在TCP首部中40个字节的选项中还包含了一个窗口扩大因子M，实际的窗口大小就是16为窗口字段的值左移M位。每移一位，扩大两倍。



##### 4.1.4.4 拥塞控制

TCP传输的过程中，发送端开始发送数据的时候，如果刚开始就发送大量的数据，那么就可能造成一些问题。网络可能在开始的时候就很拥堵，如果给网络中在扔出大量数据，那么这个拥堵就会加剧。拥堵的加剧就会产生大量的丢包，就对大量的超时重传，严重影响传输。

所以TCP引入了慢启动的机制，在开始发送数据时，先发送少量的数据探路。探清当前的网络状态如何，再决定多大的速度进行传输。这时候就引入一个叫做拥塞窗口的概念。

为了进行拥塞控制，TCP 发送方要维持一个 **拥塞窗口(cwnd)** 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。

TCP的拥塞控制采用了四种算法，即 **慢开始** 、 **拥塞避免** 、**快重传** 和 **快恢复**。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。

- **慢开始：**   慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。

- **拥塞避免：** 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.

- **快重传： ** 快重传算法要求首先接收方收到一个失序的报文段后就立刻发出重复确认，而不要等待自己发送数据时才进行捎带确认。接收方成功的接受了发送方发送来的M1、M2并且分别给发送了ACK，现在接收方没有收到M3，而接收到了M4，显然接收方不能确认M4，因为M4是失序的报文段。如果根据可靠性传输原理接收方什么都不做，但是按照快速重传算法，在收到M4、M5等报文段的时候，不断重复的向发送方发送M2的ACK,如果接收方一连收到三个重复的ACK,那么发送方不必等待重传计时器到期，由于发送方尽早重传未被确认的报文段。

- **快恢复：** 

  1.当发送发连续接收到三个确认时，就执行乘法减小算法，把慢启动开始门限（ssthresh）减半，但是接下来并不执行慢开始算法。

  2.此时不执行慢启动算法，而是把cwnd设置为ssthresh的一半， 然后执行拥塞避免算法，使拥塞窗口缓慢增大。

![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.18.png)

拥塞控制是TCP在传输时尽可能快的将数据传输，并且避免拥塞造成的一系列问题。是可靠性的保证，同时也是维护了传输的高效性。



## 4.2 UDP

[博客](https://blog.csdn.net/aa1928992772/article/details/85240358)

### 4.2.1 特点

UDP是传输层的协议，功能即为在IP的数据报服务之上增加了最基本的服务：复用和分用以及差错检测。

UDP提供不可靠服务，具有TCP所没有的优势：

1. UDP无连接，时间上不存在建立连接需要的时延。空间上，TCP需要在端系统中维护连接状态，需要一定的开销。此连接装入包括接收和发送缓存，拥塞控制参数和序号与确认号的参数。UCP不维护连接状态，也不跟踪这些参数，开销小。空间和时间上都具有优势。

   举个例子：

   DNS如果运行在TCP之上而不是UDP，那么DNS的速度将会慢很多。
   HTTP使用TCP而不是UDP，是因为对于基于文本数据的Web网页来说，可靠性很重要。
   同一种专用应用服务器在支持UDP时，一定能支持更多的活动客户机。

2. 分组首部开销小，TCP首部20字节，UDP首部8字节。

3. UDP没有拥塞控制，应用层能够更好的控制要发送的数据和发送时间，网络中的拥塞控制也不会影响主机的发送速率。某些实时应用要求以稳定的速度发送，能容 忍一些数据的丢失，但是不能允许有较大的时延（比如实时视频，直播等）

4. UDP提供尽最大努力的交付，不保证可靠交付。所有维护传输可靠性的工作需要用户在应用层来完成。没有TCP的确认机制、重传机制。如果因为网络原因没有传送到对端，UDP也不会给应用层返回错误信息

5. UDP是面向报文的，对应用层交下来的报文，添加首部后直接乡下交付为IP层，既不合并，也不拆分，保留这些报文的边界。对IP层交上来UDP用户数据报，在去除首部后就原封不动地交付给上层应用进程，报文不可分割，是UDP数据报处理的最小单位。

   正是因为这样，UDP显得不够灵活，不能控制读写数据的次数和数量。比如我们要发送100个字节的报文，我们调用一次sendto函数就会发送100字节，对端也需要用recvfrom函数一次性接收100字节，不能使用循环每次获取10个字节，获取十次这样的做法。

6. UDP常用一次性传输比较少量数据的网络应用，如DNS,SNMP等，因为对于这些应用，若是采用TCP，为连接的创建，维护和拆除带来不小的开销。UDP也常用于多媒体应用（如IP电话，实时视频会议，流媒体等）数据的可靠传输对他们而言并不重要，TCP的拥塞控制会使他们有较大的延迟，也是不可容忍的。



### 4.2.2 首部

UDP数据报分为**首部**和**用户数据部分**，整个UDP数据报作为IP数据报的数据部分封装在IP数据报中，UDP数据报文结构如图所示： 

![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.19.png)

**UDP首部有8个字节，由4个字段构成，每个字段都是两个字节:**

1. 源端口： 源端口号，需要对方回信时选用，不需要时全部置0.

2. 目的端口：目的端口号，在终点交付报文的时候需要用到。

3. 长度：UDP的数据报的长度（包括首部和数据）其最小值为8（只有首部）

4. 校验和：检测UDP数据报在传输中是否有错，有错则丢弃。

   该字段是可选的，当源主机不想计算校验和，则直接令该字段全为0.

当传输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口，上交给应用进程。
如果接收方UDP发现收到的报文中的目的端口号不正确（不存在对应端口号的应用进程0,），就丢弃该报文，并由ICMP发送“端口不可达”差错报文给对方。



## 4.3 TCP和UDP的区别

![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.20.jpg)

- TCP 是面向连接的，UDP 是面向无连接的
- UDP程序结构较简单
- TCP 是面向字节流的，UDP 是基于数据报的
- TCP 保证数据正确性，UDP 可能丢包
- TCP 保证数据顺序，UDP 不保证
- TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付 









# 5 应用层（Application Layer）

## 5.1 域名系统DNS

我们都知道，TCP/IP中使用的是IP地址和端口号来确定网络上某一台主机上的某一个程序，不免有人有疑问，为什么不用域名来直接进行通信呢？

1. 因为IP地址是固定长度的，IPv4是32位，IPv6是128位，而域名是变长的，不便于计算机处理。
2. IP地址对于用户来说不方便记忆，但域名便于用户使用，例如www.baidu.com这是百度的域名。
   总结一点就是IP地址是面向主机的，而域名则是面向用户的。

### 5.1.1 域名结构

域名系统必须要保持唯一性。
为了达到唯一性的目的，因特网在命名的时候采用了层次结构的命名方法：

1. 每一个域名（本文只讨论英文域名）都是一个标号序列（labels），用字母（A-Z，a-z，大小写等价）、数字（0-9）和连接符（-）组成

2. 标号序列总长度不能超过255个字符，它由点号分割成一个个的标号（label）

3. 每个标号应该在63个字符之内，每个标号都可以看成一个层次的域名。

4. 级别最低的域名写在左边，级别最高的域名写在右边。

   **域名服务主要是基于UDP实现的，服务器的端口号为53。**

![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.2.png)





### 5.1.2 域名分级

![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.3.png)



其中顶级域名分为：国家顶级域名、通用顶级域名、反向域名。

| 国家顶级域名 | 中国:cn， 美国:us，英国uk…                                   |
| ------------ | ------------------------------------------------------------ |
| 通用顶级域名 | com公司企业，edu教育机构，gov政府部门，int国际组织，mil军事部门 ，net网络，org非盈利组织… |
| 反向域名     | arpa，用于PTR查询（IP地址转换为域名）                        |



### 5.1.3 域名服务器

域名需要由遍及全世界的域名服务器去解析，域名服务器实际上就是装有域名系统的主机。由高向低进行层次划分，可分为以下几大类：

- 根域名服务器：    最高层次的域名服务器，也是最重要的域名服务器，本地域名服务器如果解析不了域名就会向根域名服务器求助。由于每分钟都要解析的名称数量多得令人难以置信，所以实际上每个根服务器都有镜像服务器，**每个根服务器与它的镜像服务器共享同一个  IP 地址，**当你对某个根服务器发出请求时，请求会被路由到该根服务器离你最近的镜像服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和地址，如果向根服务器发出对 `“jocent.me”` 的请求，则根服务器是不能在它的记录文件中找到与` “jocent.me”` 匹配的记录。但是它会找到 `“me”` 的顶级域名记录，并把负责` “me”` 地址的顶级域名服务器的地址发回给请求者。
- 顶级域名服务器：负责管理在该顶级域名服务器下注册的二级域名。当根域名服务器告诉查询者顶级域名服务器地址时，查询者紧接着就会到顶级域名服务器进行查询。比如还是查询`"jocent.me"`，根域名服务器已经告诉了查询者`“me”`顶级域名服务器的地址，`“me”`顶级域名服务器会找到 `“jocent.me”`的域名服务器的记录，域名服务器检查其区域文件，并发现它有与 `“jocent.me”` 相关联的区域文件。在此文件的内部，有该主机的记录。此记录说明此主机所在的 IP 地址，并向请求者返回最终答案。
- 权限域名服务器：负责一个区的域名解析工作
- 本地域名服务器：当一个主机发出DNS查询请求的时候，这个查询请求首先就是发给本地域名服务器的。

![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.4.png)



### 5.1.4 域名解析过程

1. 主机先向本地域名服务器进行递归查询
2. 本地域名服务器采用迭代查询，向一个根域名服务器进行查询
3. 根域名服务器告诉本地域名服务器，下一次应该查询的顶级域名服务器的IP地址
4. 本地域名服务器向顶级域名服务器进行查询
5. 顶级域名服务器告诉本地域名服务器，下一步查询权限服务器的IP地址
6. 本地域名服务器向权限服务器进行查询
7. 权限服务器告诉本地域名服务器所查询的主机的IP地址
8. 本地域名服务器最后把查询结果告诉主机 





## 5.2 HTTP协议

[博客1](https://blog.csdn.net/a19881029/article/details/14002273)

[博客2](https://www.cnblogs.com/EricaMIN1987_IT/p/3837436.html)

##### 5.2.1 概念

协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。 

HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。 

在Internet中所有的传输都是通过TCP/IP进行的。HTTP协议作为TCP/IP模型中应用层的协议也不例外。HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。如下图所示：

 ![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.10.png)

HTTP默认的端口号为80，HTTPS的端口号为443。 

浏览网页是HTTP的主要应用，但是这并不代表HTTP就只能应用于网页的浏览。HTTP是一种协议，只要通信的双方都遵守这个协议，HTTP就能有用武之地。比如咱们常用的QQ，迅雷这些软件，都会使用HTTP协议(还包括其他的协议)。

 

##### 5.2.2 特点

1.支持客户/服务器模式。

2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。

3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。

4.无连接：每次请求一次，释放一次连接。所以无连接表示每次连接只能处理一个请求。优点就是节省传输时间，实现简单。我们有时称这种无连接为短连接。对应的就有了长链接，长连接专门解决效率问题。当建立好了一个连接之后，可以多次请求。但是缺点就是容易造成占用资源不释放的问题。当HTTP协议头部中字段Connection：keep-alive表示支持长链接。

5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。为了解决HTTP协议无状态，于是，两种用于保持HTTP连接状态的技术就应运而生了，一个是Cookie，而另一个则是Session。



##### 5.2.3 Connection: keep-alive

无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。

从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。

Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。

 

 

##### 5.2.4 工作流程

一次HTTP操作称为一个事务，其工作过程可分为四步：

1. 首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。
2. 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。
3. 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。
4. 客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。

如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。

**HTTP是基于传输层的TCP协议，所以HTTP在开始传输之前，首先需要建立TCP连接，而TCP连接的过程需要所谓的三次握手和四次挥手。**

**在TCP三次握手之后，建立了TCP连接，此时HTTP就可以进行传输了。一个重要的概念是面向连接，既HTTP在传输完成之间并不断开TCP连接。在HTTP1.1中(通过Connection头设置)这是默认行为。**

 

##### 5.2.5 HTTP请求报文格式

HTTP请求报文主要由请求行、请求头部、请求正文3部分组成。

![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.5.png)



**1.请求行**

| 组成部分(之间由空格分隔) | 内容                                                         |
| ------------------------ | ------------------------------------------------------------ |
| 请求方法                 | 包括GET、HEAD、PUT、POST、TRACE、OPTIONS、DELETE以及扩展方法<br>当然并不是所有的服务器都实现了所有的方法，部分方法即便支持，处于安全性的考虑也是不可用的 |
| URL                      | ---                                                          |
| 以及协议版本             | HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1           |





**2.请求头部**

请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔

常见请求头如下：

![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.6.png)

请求头部的最后会有一个空行，表示请求头部结束，接下来为请求正文，这一行非常重要，必不可少 



**3.请求正文**

可选部分，比如GET请求就没有请求正文





##### 5.2.6 HTTP响应报文格式

HTTP响应报文主要由状态行、响应头部、响应正文3部分组成

![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.7.png)

**1.状态行**

由3部分组成，分别为：协议版本，状态码，状态码描述，之间由空格分隔。

| 状态代码 | 含义                               |
| -------- | ---------------------------------- |
| 1xx      | HTTP/1.1向协议中引入了信息性状态码 |
| 2xx      | 表示成功                           |
| 3xx      | 指资源重定向                       |
| 4xx      | 指客户端请求出错                   |
| 5xx      | 指服务端出错                       |

这里列举几个常见的：

![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.8.png)



**2.响应头部**

与请求头部类似，为响应报文添加了一些附加信息

常见响应头部如下：

![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.9.png)





## 5.3 SMTP协议

[博客](https://blog.csdn.net/qq_35644234/article/details/68961603)

SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件   的规则，由它来控制信件的中转方式。 

**是一种TCP协议支持的提供可靠且有效电子邮件传输的应用层协议。** 



##### 5.3.1 过程

- 连接建立：SMTP客户和SMTP服务器首先要建立TCP连接。

> SMTP客户和SMTP服务器首先要建立TCP连接。
>
> 1. 从客户端使用熟知端口号25建立与服务器的TCP连接，SMTP服务器向该客户送回应答码220，并且还为客户端提供了服务器的域名
> 2. 客户端收到应答码后，发送HELO命令，启动客户端和服务器之间的SMTP会话。该客户端发送的HELO用来向服务器提供客户端的标识信息
> 3. 服务器端回应应答码250，通知客户端：请求建立邮件服务会话已经实现



- 报文发送
- 连接终止



##### 5.3.2 MIEME协议

Multipurpose Internet Mail Extensions 

MIME试图在不改变SMTP协议和RFC822（邮件格式标准）的基础上，使得邮件可以传送任意二进制文件。另外，MIME 协议的数据格式也可以避免邮件内容在传输过程中发生信息丢失。MIME协议不是对RFC822邮件格式的升级和替代，而是基于RFC822邮件格式的扩展应用。一言以蔽之，RFC822定义了邮件内容的格式和邮件头字段的详细细节，MIME协议则是定义了如何在邮件体部分表达出的丰富多样的数据内容。



**改进措施：**

1. 新增了一些邮件头信息，用来协商MIME的一些参数。
2. 定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。
3. 定义了传送编码，从而可以传送任意二进制文件。



## 5.4 FTP-文件传输协议

工作在TCP/IP模型的应用层，**基于的传输协议是TCP**，FTP客户端和服务器之间的连接是可靠的，面向连接的，为数据的传输提供了可靠的保证。 

与一般的 C/S 应用不同点在于一般的C/S 应用程序一般只会建立一个 Socket 连接，这个连接同时处理服务器端和客户端的连接命令和数据传输。**而FTP协议中将命令与数据分开传送的方法提高了效率。**

 FTP 使用 2 个端口，一个数据端口和一个命令端口（也叫做控制端口）。这两个端口一般是21 （命令端口）和 20 （数据端口）。控制  Socket 用来传送命令，数据 Socket 是用于传送数据。每一个 FTP 命令发送之后，FTP  服务器都会返回一个字符串，其中包括一个响应代码和一些说明信息。其中的返回码主要是用于判断命令是否被成功执行了。



 Socket 客户端编程主要步骤如下：

1. socket() 创建一个 Socket
2. connect() 与服务器连接
3. write() 和 read() 进行会话
4. close() 关闭 Socket





## 5.5 TFTP-简单文件传输协议

[博客](https://www.cnblogs.com/chusiyong/p/11389442.html)

Trivial File Transfer Protocol 

TFTP是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为69。

**它基于UDP协议而实现**，协议设计的时候是进行小文件传输的。因此它不具备通常的FTP的许多功能，它只能从文件服务器上获得或写入文件，不能列出目录，不进行认证，它传输8位数据。常用于嵌入式设备开发中。 



##### 5.5.1 传输模式

文件在传输的过程中需要指明数据的表示方式：

| 模式名称 | 模式含义                          | 说明       |
| -------- | --------------------------------- | ---------- |
| netascii | 文本传输模式，按照一个字节8位解析 | 文本模式   |
| octet    | 二进制模式，数据无需解析          | 二进制模式 |
| mail     | 已过时，不使用                    | 已过时     |

##### 5.5.2 报文类型

TFTP共定义了五种类型的包格式，格式的区分由包数据前两个字节的Opcode字段区分，分别是：

- 读文件请求包：Read request，简写为RRQ，对应Opcode字段值为1
- 写文件请求包：Write requst，简写为WRQ，对应Opcode字段值为2
- 文件数据包：Data，简写为DATA，对应Opcode字段值为3
- 回应包：Acknowledgement，简写为ACK，对应Opcode字段值为4
- 错误信息包：Error，简写为ERROR，对应Opcode字段值为5



##### 5.5.3 协议模式

TFTP 协议模式类似于客户端发送请求，服务器进行响应。由于 TFTP 是基于 UDP 协议的，而 UDP 数据包本身就不是很安全，即发送端发送的数据是否能成功到达接收端是不能确定的。    因此，为了能够让发送端知道接收端已经接收到了发送端发来的数据包，接收端对接收到的每一个数据包都进行确认。 



##### 5.5.4 TFTP协议的缺陷

1. 传输效率低
2. 对于超时机制没有明确说明
3. 每包长度固定为512字节，不灵活





## 5.6 远程登录（Telnet）

[博客](https://blog.csdn.net/sundacheng1989/article/details/51005050)

Telnet最常见的是对服务器的远程登录，现在随着各种远程登录方式的普及，比如说远程桌面连接或者一些其他现成的工具连接Linux或者Windows服务器，telnet这种登录方式已经渐渐远去。 



##### 5.6.1 工作流程

当你用Telnet登录进入远程计算机系统时，你事实上启动了两个程序，一个 叫Telnet客户程序，它运行在你的本地机上(端口一般为23)；另一个叫Telnet服务器程序，它运 行在你要登录的远程计算机上。本地机上的客户程序要完成如下功能： 

1. 建立与服务器的TCP 联接； 
2. 从键盘上接收你输入的字符； 
3. 把你输入的字符串变成标准格式并送给远程服务器； 
4. 从远程服务器接收输出的信息； 
5. 把该信息显示在你的屏幕上。 



##### 5.6.2 工作原理

telnet是**以TCP为基础与服务器进行通信**，所以它的功能远不止远程登录服务器（远程操纵服务器）。不管是什么协议，如果它基于 tcp/ip，那么你使用 TcpClient（或者 Socket）连接它，然后发点信息，依然能连通。Telnet可以看作是一种TCP的连接工具。 

> Http是通过TCP连接传输字符，但是数据格式是HTTP协议规定的格式。简单来说，所谓的HTTP协议，FTP协议，SMTP协议，就是各自规定了以什么样的数据包方式在网络上通过TCP管道传输数据。 

比如，telnet可以和SMTP进行通信：因为SMTP也是基于tcp的

![](D:/Jessica(note)/Marie(2019)/programming/08%E6%80%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/1.29.png)

如上图所示，这是在一台Linux机器上向互联网中的一台邮件服务器发送邮件。首先输入命令telnet smtp.wo.cn 25，这smtp.wo.cn是地址，在互联网中会通过DNS服务器转换成IP地址，25指的是端口，也就是连接邮箱服务器的25端口。（telnet甚至可以与web服务器的80号端口进行通信）。这里与邮件服务器的连接连通后，发现服务器回复了一些问候信息，这时只要向服务器传送邮件内容就可以了。







## 5.7 SNMP-简单网络管理协议

[博客](https://blog.csdn.net/qq_28657577/article/details/82257343)

##### 5.7.1 什么是SNMP

SNMP是简单的网络管理协议，它不是一个软件，而是用于网络管理的**一套规则**。利用SNMP，**一个管理工作站可以远程管理所有支持这种协议的网络设备，包括监视网络状态、修改网络设备配置、接收网络事件警告**等。



##### 5.7.2 为什么要使用SNMP协议

因为网络设备可能来自不同的厂商，如果每个厂商提供一套独立的管理接口，将使网络管理变得越来越复杂，若想对网络中来自不同厂商的设备监控，用基于SNMP开发的软件进行管理最方便的，因为大部分的设备都支持SNMP协议。



##### 5.7.3 技术要点

（1）**基于TCP/IP互联网的标准协议，传输层协议一般用UDP**

（2）自动化网络管理。网络管理员可以利用SNMP平台在网络上的节点检索信息、修改信息、发现故障、完成故障诊断、进行容量规划和生成报告

（3）屏蔽不同设备的物理差异，实现对不同厂商产品的自动化管理。SNMP只提供最基本得功能集，使得管理任务与被管理设备的物理特征和实际网络类型相对独立，从而实现对不同厂商设备的管理

（4）简单的请求-应答方式和主动通告方式相结合，并有超时和重传机制

（5）报文种类少，报文格式简单，方便解析，易于实现

（6）SNMPv3版本提供了认证和加密安全机制，以及基于用户和视图的访问控制功能，增强了安全性

 

##### 5.7.4 SNMP的网络架构

SNMP网络架构由三部分组成：NMS（网络管理站）、Agent（代理）、MIB（管理信息库）

1. NMS（网络管理站）

NMS是网络中的管理者，是一个利用SNMP协议对网络设备进行管理和监视的系统。

 

2.Agent

Agent是网络设备中的一个应用模块，用于维护被管理设备的信息数据，并响应NMS的请求，把管理数据汇报给发送请求的NMS。

 

3.MIB

任何一个被管理的资源都表示成一个对象，称为被管理的对象。MIB就是被管理对象的集合。它定义了被管理对象的一系列的属性：对象的名称、对象的访问权限和对象的数据类型等。每个Agent都有自己的MIB。MIB也可以看做是NMS和Agent之间的一个接口，通过这个接口，NMS可以对Agent中的每一个被管理对象进行读/写操作，从而达到管理和监控设备的目的。

 

NMS、Agent和MIB之间的关系如图所示：

 ![img](https://img-blog.csdn.net/20131027023213796?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2htaWx5X2NtbDA2MDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

 

MIB的结构：

MIB是以树状结构进行存储的，树的节点表示被管理对象，它可以用从根开始的一条路径唯一地识别，这条路径就称为OID。

如图所示，管理对象system可以用一串数字{1.3.6.1.2.1.1}唯一标识，这串数字就是system的OID。

 ![img](https://img-blog.csdn.net/20131027022423968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2htaWx5X2NtbDA2MDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

 



[超级好的一篇博客，总结了ip/tcp协议簇](https://developer.51cto.com/art/201906/597961.htm#topx)


