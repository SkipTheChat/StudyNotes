[点我做题](https://www.nowcoder.com/test/question/2f4e5587a0c94fccb36642d3c3b0c6b1?pid=21910764&tid=36081677)

# 表达式求值

### 信息卡片 

- 时间： 2020-8-17
- 题目描述：

```
给出一个布尔表达式的字符串，比如：true or false and false，表达式只包含true，false，and和or，现在要对这个表达式进行布尔求值，计算结果为真时输出true、为假时输出false，不合法的表达时输出error（比如：true true）。表达式求值是注意and 的优先级比 or 要高，比如：true or false and false，等价于 true or (false and false)，计算结果是 true。


输入描述:
输入第一行包含布尔表达式字符串s，s只包含true、false、and、or几个单词（不会出现其它的任何单词），且单词之间用空格分隔。 (1 ≤ |s| ≤ 103).

输出描述:
输出true、false或error，true表示布尔表达式计算为真，false表示布尔表达式计算为假，error表示一个不合法的表达式。

输入例子1:
and

输出例子1:
error

输入例子2:
true and false

输出例子2:
false

输入例子3:
true or false and false

输出例子3:
true
```



### 参考答案

```js
package wpt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Stack;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] nums = br.readLine().split(" ");
        //如果是偶数一定不符合表达式规则
        if(nums.length % 2 == 0){
            System.out.println("error");
            return;
        }

        // 如果顺序不对一定不符合表达式规则
        for (int i = 0; i < nums.length; i++) {
            if(i % 2 == 0){
                if(!"true".equals(nums[i]) && !"false".equals(nums[i])){
                    System.out.println("error");
                    return;
                }
            }else{
                if(!"or".equals(nums[i]) && !"and".equals(nums[i])){
                    System.out.println("error");
                    return;
                }
            }
        }
        
        Stack<String> stack1 = new Stack<>();
        Stack<String> stack2 = new Stack<>();
        int i = 0;
        // 用栈，栈1存true/false，栈2存or/and
        // 如果是and，就直接求然后压回栈1
        while(i < nums.length){
            if("false".equals(nums[i]) || "true".equals(nums[i])){
                stack1.push(nums[i]);
            }else if("and".equals(nums[i])){
                i++;
                String a = stack1.pop();
                String b = nums[i];
                if("false".equals(a) || "false".equals(b)){
                    stack1.push("false");
                }
            }else if("or".equals(nums[i])){
                stack2.push("or");
            }
            i++;
        }

        // and都求完了，现在只剩下or
        while(!stack2.isEmpty()){
            String a = stack1.pop();
            String b = stack1.pop();
            String c = stack2.pop();
            if("true".equals(a) || "true".equals(b)){
                stack1.push("true");
            }else{
                stack1.push("false");
            }
        }
        System.out.println(stack1.pop());
    }
}

```



> case通过率为94.12%



# 字符串模式匹配

### 信息卡片 

- 时间： 2020-8-17
- 题目描述：

```
给出两个字符串，分别是模式串P和目标串T，判断模式串和目标串是否匹配，匹配输出 1，不匹配输出 0。模式串中‘？’可以匹配目标串中的任何字符，模式串中的 ’*’可以匹配目标串中的任何长度的串，模式串的其它字符必须和目标串的字符匹配。例如P=a?b，T=acb，则P 和 T 匹配。


输入描述:
输入第一行包含一个字符串p， (1 ≤ |p| ≤ 20).

输入第二行包含一个字符串t， (1 ≤ |t| ≤ 20).


输出描述:
输出仅包含0和1的整数，0表示p和t不匹配，1表示p和t匹配。


输入例子1:
a?b
ab

输出例子1:
0

输入例子2:
a*b
ab

输出例子2:
1

输入例子3:
a*b
a(cb

输出例子3:
1
```



### 参考答案

```js
package wpt;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String a = br.readLine();
        String b = br.readLine();
        int result = find(a, b, 0, 0) ? 1 : 0;
        System.out.println(result);
    }

    private static boolean find(String a, String b, int i, int j) {
        // 如果最后一个是‘*’,那么就是特例
        if(i == a.length() - 1 && a.charAt(i) ==  '*'){
            return true;
        }

        // 如果最后一个不是'*'
        if(i >= a.length() && j >= b.length()){
            return true;
        }else if(i >= a.length() || j >= b.length()){
            return false;
        }

        char strA = a.charAt(i);
        char strB = b.charAt(j);
        if (strA == '?') { // 匹配？
            return find(a, b, i + 1, j + 1);
        }else if(strA == '*'){ //匹配*
            return find(a,b,i + 1,j) || find(a,b,i,j + 1);
        }else{ // 匹配除了普通字符
            if(strA != strB){
                return false;
            }else{
                return find(a,b,i + 1,j + 1);
            }
        }
    }
}

```





# 订单分配

### 信息卡片 

- 时间： 2020-8-17
- 题目描述：

```
打车派单场景, 假定有N个订单， 待分配给N个司机。每个订单在匹配司机前，会对候选司机进行打分，打分的结果保存在N*N的矩阵A， 其中Aij 代表订单i司机j匹配的分值。

假定每个订单只能派给一位司机，司机只能分配到一个订单。求最终的派单结果，使得匹配的订单和司机的分值累加起来最大，并且所有订单得到分配。


输入描述:
第一行包含一个整数N，2≤N≤10。

第二行至第N+1行包含N*N的矩阵。


输出描述:
输出分值累加结果和匹配列表，结果四舍五入保留小数点后两位
（注意如果有多组派单方式得到的结果相同，则有限为编号小的司机分配编号小的订单，比如：司机1得到1号单，司机2得到2号单，就比司机1得到2号单，司机2得到1号单要好）

输入例子1:
3
1.08 1.25 1.5
1.5 1.35  1.75
1.22 1.48 2.5

输出例子1:
5.25
1 2
2 1
3 3

例子说明1:
第一行代表得到的最大分值累加结果5.25，四舍五入保留两位小数；

第二行至第四行代表匹配的结果[i j],其中i按行递增：

订单1被派给司机2，订单2被派给司机1，订单3被派给司机3。使得A12+ A21+ A33= 1.25 + 1.5 + 2.5 = 5.25在所有的组合中最大。
```



### 参考答案

```java
3
1.08 1.25 1.5
1.5 1.35 1.75
1.22 1.48 2.5
    package wpt;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        String[][] strs = new String[n][n];
        int[] cols = new int[n]; // 0表示没有占位，1表示占位了
        int[] rows = new int[n];
        for (int i = 0; i < n; i++) {
            strs[i] = br.readLine().split(" ");
        }
//        String a = br.readLine();
//        String b = br.readLine();

        float max = 0;
        for (int i = 0; i < n; i++) { // 列
            float sum = 0;
            for (int j = 0; j < n; j++) { // 行
                for (int k = 0; k < cols.length; k++) {
                    for (int l = 0; l < rows.length; l++) {
                        if(cols[k] == 0 && rows[l] == 0){
                            sum += Float.parseFloat(strs[j][i]);
                            cols[k] = 1;
                            rows[l] = 1;
                            break;
                        }
                    }
                }
            }
            Arrays.fill(cols,0);
            Arrays.fill(rows,0);
            max = Math.max(max,sum);
        }

        System.out.println(max);
    }

}

```



# 美团骑手包裹区间分组

### 信息卡片 

- 时间： 2020-8-17
- 题目描述：

```
2110年美团外卖火星第3000号配送站点有26名骑手，分别以大写字母A-Z命名，因此可以称呼这些骑手为黄家骑士特工A，黄家骑士特工B…黄家骑士特工Z，某美团黑珍珠餐厅的外卖流水线上会顺序产出一组包裹，美团配送调度引擎已经将包裹分配到骑手，并在包裹上粘贴好骑手名称，如RETTEBTAE代表一组流水线包裹共9个，同时分配给了名字为A B E R T的5名骑手。请在不打乱流水线产出顺序的情况下，把这组包裹划分为尽可能多的片段，同一个骑手只会出现在其中的一个片段，返回一个表示每个包裹片段的长度的列表。


输入描述:
输入数据只有一行，为一个字符串(不包含引号)，长度不超过1000，只包含大写字母'A'到'Z'，字符之间无空格。


输出描述:
输出每个分割成片段的包裹组的长度，每个长度之间通过空格隔开


输入例子1:
MPMPCPMCMDEFEGDEHINHKLIN

输出例子1:
9 7 8

例子说明1:
划分结果为MPMPCPMCM,DEFEGDE,HINHKLIN。

每个骑手最多出现在一个片段中。

像MPMPCPMCMDEFEGDE,HINHKLIN的划分是错误的，因为划分的片段数较少。
```



### 参考答案

```java

```

