# 大数加法

### 信息卡片 

- 时间： 2020-8-16
- 题目描述：

```
以字符串的形式读入两个数字，再以字符串的形式输出两个数字的和。

输入描述:
输入两行，表示两个数字a和b，-109 <= a , b <= 109  ，用双引号括起。
输出描述:
输出a+b的值，用双引号括起。

输入例子1:
"-26"
"100"
输出例子1:
"74"
```



### 参考答案



```js
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigDecimal;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String a1 = br.readLine();
        String b1 = br.readLine();
        String a = a1.substring(1,a1.length() - 1);
        String b = b1.substring(1,b1.length() - 1);
        BigDecimal a2 = new BigDecimal(a);
        BigDecimal b2 = new BigDecimal(b);
        System.out.println("\"" + a2.add(b2) + "\"");
    }

}

```



# 回文子串

### 信息卡片 

- 时间： 2020-8-16
- 题目描述：

```
给定一个字符串，你的任务是计算这个字符串中有多少个回文子串（回文串是一个正读和反读都一样的字符串）。

具有不同开始位置或结束位置的回文串，即使是由相同的字符组成，也会被计为是不同的子串。


输入描述:
输入仅包含一个字符串，长度不会超过 1000。


输出描述:
输出仅包含一个非负整数， 代表输入字符串有多少个回文子串。


输入例子1:
abc

输出例子1:
3

输入例子2:
aaa

输出例子2:
6
```



### 参考答案



```js
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String str = br.readLine();

        int count = 0;
        for (int i = 0; i < str.length(); i++) {
            count += help(i,i,str);
            count += help(i,i + 1,str);
        }
        System.out.println(count);
    }

    private static int help(int start, int end, String str) {
        int count = 0;
        while(start >= 0  && end < str.length() && str.charAt(start) == str.charAt(end)){
            count++;
            start--;
            end++;
        }
        return count;
    }

}

```





# 合并金币

### 信息卡片 

- 时间： 2020-8-16
- 题目描述：

```
链接：https://www.nowcoder.com/questionTerminal/6d3ccbc5b6ad4f12b8fe4c97eaf969e0
来源：牛客网

有 N 堆金币排成一排，第 i 堆中有 C[i] 块金币。每次合并都会将相邻的两堆金币合并为一堆，成本为这两堆金币块数之和。经过N-1次合并，最终将所有金币合并为一堆。请找出将金币合并为一堆的最低成本。

其中，1 <= N <= 30，1 <= C[i] <= 100


输入描述:
第一行输入一个数字 N 表示有 N 堆金币
第二行输入 N 个数字表示每堆金币的数量 C[i]


输出描述:
输出一个数字 S 表示最小的合并成一堆的成本
示例1
输入
4
3 2 4 1
输出
20
示例2
输入
30
10 20 30 40 50 60 70 80 90 100 99 89 79 69 59 49 39 29 19 9 2 12 22 32 42 52 62 72 82 92
输出
7307
```



### 参考答案

[参考博客](https://blog.csdn.net/q763562998/article/details/105440772)

```js
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n=scanner.nextInt();
        int array[][]=new int[n+1][n+1];
        int sum[]=new int[n+1];
        for (int i = 1; i < n+1; i++) {
            int a=scanner.nextInt();
            sum[i]=sum[i-1]+a;
        }
        for (int len = 2; len <=n ; len++) {//一堆有多少组成
            //比如len=2  就是组合二堆为1堆
            //len=3 就是组合三堆为1堆
            for (int i = 1; i <=n-len+1 ; i++) {//起点
                int j=i+len-1;//终点
                array[i][j]=Integer.MAX_VALUE;//为了一开始得到最小值
                int leastSum=sum[j]-sum[i-1];
                for (int k=i;k<j;k++) {
                    //转移方程就是因为合成一堆有不同的组合方法
                    //如2  3   6  1
                    //当len=2时 ，组合有2  3    3   6     6  1
                    //获取当前组合的最小值
                    //当len=3
                    //组合有 一堆是2 3 6    组合为2 3     6   组合为2    3 6
                    //比如组合2  3  6  就要获取2 3的最优解  3 6的最优解
                    //当Len=4
                    //组合有2 3 6 1    2 3 6     1       2   3  6  1
                    //因为之前已经得到了2 3 6 的最优解 和 3  6  1的最优解
                    //继续比较两者到底谁小


                    //这句话是真的核心
                    //从因为k刚开始是从i开始
                    //所以一开始也就是从i 开始到i结束所需成本+从i+1开始到j的成本
                    //然后循环后是从i到i+1结束的成本+从i+1+1到j的成本
                    //总的来说也就是从i到j 它要分成j-i个部分来相加求和找最小
                    //从前一段到后一段，从前一段到后一段
                    //前一段从0到最后
                    //后一段从最后到0


                    //sum 就是此次成本
                    //因为不管是从i到j哪一次
                    //最后的相加的成本一定是从i到j所有数字之和
                    //比方说2 3 6  最后一次肯定是2+3+6
                    //所以最后一定要加上11  不管是从2 3  还是 3 6  先合成一堆
                    array[i][j]=Math.min(array[i][j],array[i][k]+array[k+1][j]+leastSum);
                }
            }
        }
        System.out.println(array[1][n]);
    }
}


```



# 最小唯一前缀

### 信息卡片 

- 时间： 2020-8-16
- 题目描述：

```
给定一组个字符串，为每个字符串找出能够唯一识别该字符串的最小前缀。


输入描述:
第一行输入一个整数 n 表示字符串个数
后面n行，每行一个字符串，一共n串互不相同的字符串。（2 <= n <= 100，字符串长度不超过100）


输出描述:
输出n行，每行一个字符串，依次是每个字符串的最小可唯一识别前缀
示例1
输入
5
meituanapp
meituanwaimai
dianpingliren
dianpingjiehun
mt
输出
meituana
meituanw
dianpingl
dianpingj
mt

备注:
如果一个字符串S是另一个字符串T的前缀，则S的最小可识别前缀为S；
```



### 参考答案

暴力法

```js
import java.util.Scanner;  

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        String[] strings = new String[N];
        for (int i = 0; i < N; i++)
            strings[i] = scanner.next();
        scanner.close();
        for (String s : strings)
            System.out.println(unique(s, strings));
    }
    //返回字符串s在字符串数组strings中最短唯一前缀
    private static String unique(String s, String[] strings) {
        String prefix = s.substring(0, 1);//前缀初始为首字符
        for (String single : strings) {
            if (single.equals(s))//跳过字符串s本身
                continue;
            while (single.indexOf(prefix) == 0 && prefix.length() < s.length()) //字符串single与字符串s具有相同的前缀prefix，前缀需要往后延长
                prefix = s.substring(0, prefix.length()+1);
        }
        return prefix;
    }
}

```

