# 第一题

```
小强在研究有关字典序的问题，同长度下的字典序比较顺序为从左到右，比如"ac" < "ad","bc" > "ad".

他想知道如果每种字母组合都能构成一个单词，给定长度为n的两个单词A和B，字典序小于B但是大于A且长度等于n的单词有多少个。

输入描述：

第一行输入一个整数T，表示数据组数。

随后T行，每行开头一个整数n，表示单词A和B的长度，随后两个仅有小写字母组成的单词A，B

如果A的字典序大于B，输出0

对于30%的数据有 n <= 3

对于100%的数据有1 <= n <= 10,1 <= T <= 5000

输出描述：

输出T行，每行一个整数，表示答案

示例：

4

1 z a

1 a z

2 az bb

3 bbb bbb



输出

0

24

1

0
```



> 思路

转化成26进制数，然后相减并减1



> 代码

```java
package wpt;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int T = scanner.nextInt();
        for (int j = 0; j < T; j++) {
            int n = scanner.nextInt();
            String s1 = scanner.next();
            String s2 = scanner.next();
            long sum = 0;
            sum += find(s1,s2,n);
            long res = sum;
            if(res < 0){
                res = 0;
            }
            System.out.println(res);
        }
    }

    // 将字符串转化为26进制,相减后 - 1就是中间数的个数
    private static long find(String a, String b, int n) {
        long sumA = 0;
        long sumB = 0;
        char[] ar = a.toCharArray();
        char[] br = b.toCharArray();
        for (int i = 0; i < ar.length; i++) {
            sumA += (ar[i] - 'a') * (long) Math.pow(26,n - 1 - i);
        }

        for (int i = 0; i < br.length; i++) {
            sumB += (br[i] - 'a') * (long) Math.pow(26,n - 1 - i);
        }
        return sumB - sumA - 1;
    }
}
```



# 第二题

[博客](https://blog.csdn.net/ACM_Ted/article/details/8010170?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1.nonecase)

贪心法

```
情况一：先考虑a集合（0集合），对于这个集合，我们只要杀死其中一个，就可以通过获取敌人的武器在不消耗更多的耐久的情况下消灭这个集合的所有人。因此我们选择用自己的武器杀死这个集合中消耗耐久最少的敌人且获取了这个集合中所有的武器。接着，我们可以把b集合按ai值从小到大排序，然后用从a集合中获取的武器杀死ai代价较大的敌人。如果这个时候敌人消灭完了，就输出。如果还有剩余的敌人，我们把a集合中之前是用敌人的武器杀死的和b集合中剩下的敌人放在一起考察，此时有两种情况：1）用自己的武器杀掉a集合中原来用敌人武器杀掉的中ai代价最小的，同时可以用这个原来杀他的敌人武器杀掉b集合中剩下的ai代价的最大的。2）用自己的武器杀掉b为0中a最小的。

情况二：先考虑b集合，把b集合的敌人处理完，如果还有多余的耐久度再处理a集合的敌人。
```