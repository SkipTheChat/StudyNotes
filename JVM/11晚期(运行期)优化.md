# 1 概述

为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler，下文中简称JIT编译器）。

并没有规定虚拟机一定要使用即时编译器，但是即时编译器编译性能的好坏、代码优化程度的高低却是衡量一款商用虚拟机优秀与否的最关键的指标之一。





# 2 HotSpot虚拟机内的即时编译器

抛出问题：

- 为何HotSpot虚拟机要使用解释器与编译器并存的架构？  
- 为何HotSpot虚拟机要实现两个不同的即时编译器？
- 程序何时使用解释器执行？何时使用编译器执行？
- 哪些程序代码会被编译为本地代码？如何编译为本地代码？
- 如何从外部观察即时编译器的编译过程和编译结果？  



### 2.1 解释器与编译器

HotSpot虚拟机中内置了两个即时编译器，分别称为Client Compiler和Server Compiler，或者简称为C1编译器和C2编译器。 HotSpot虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式。

用Client Compiler获取更高的编译速度，用Server Compiler来获取更好的编译质量，在解释执行的时候也无须再承担收集性能监控信息的任务。  

- 解释器的作用：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。
- 编译器的作用：在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。

总结：当程序运行环境中内存资源限制较大（如部分嵌入式系统中），可以使用解释执行节约内存，反之可以使用编译执行来提升效率 。



### 2.2 分层编译

分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次。

- 第0层，程序解释执行，解释器不开启性能监控功能（Profiling），可触发第1层编译。
- 第1层，也称为C1编译，将字节码编译为本地代码，进行简单、 可靠的优化，如有必要将加入性能监控的逻辑。 
- 第2层（或2层以上），也称为C2编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。

实施分层编译后，Client Compiler和Server Compiler将会同时工作，许多代码都可能会被多次编译，用Client Compiler获取更高的编译速度，用Server Compiler来获取更好的编译质量，在解释执行的时候也无须再承担收集性能监控信息的任务。



### 2.3 编译对象与触发条件

##### 2.3.1 在运行过程中会被即时编译器编译的“热点代码”有两类

- 被多次调用的方法
- 被多次执行的循环体

对于第一种情况，由于是方法调用触发的编译，因此编译器理所当然地会以整个方法作为编译对象。

而对于后一种情况，尽管编译动作是由循环体所触发的，但编译器依然会以整个方法（而不是单独的循环体）作为编译对象。这种编译方式因为编译发生在方法执行过程之中，因此形象地称之为栈上替换（On Stack Replacement，简称为OSR编译，即方法栈帧还在栈上，方法就被替换了）。  



##### 2.3.2 热点探测

1. 基于采样的热点探测 ：采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”。
   * 优点：实现简单、高效，还可以很容易地获取方法调用关系
   * 缺点：很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。 



2. 基于计数器的热点探测：采用这种方法的虚拟机会为每个方法（甚至是代码）建立计数器，统计方法的执行次数，统计结果相对来说更加精确和严谨。



 在HotSpot虚拟机中使用的是基于计数器的热点探测方法，因此它为每个方法准备了两类计数器：**方法调用计数器和回边计数器(统计一个方法中循环体代码执行的次数 )**。  



### 2.4 编译优化

优化前的代码：

```java
static class B {
    int value;
    final int get() {
      return value;
    }
}
public void foo() {
    y = b.get();
    // ...do stuff...
    z = b.get();
    sum = y + z;
}
```



第一步进行方法内联（Method Inlining），方法内联的重要性要高于其他优化措施，它的主要目的有两个，一是去除方法调用的成本（如建立栈帧等），二是为其他优化建立良好的基础，方法内联膨胀之后可以便于在更大范围上采取后续的优化手段。



 内联后的代码：

```java
public void foo() {

    y = b.value;

    // ...do stuff...

    z = b.value;

    sum = y + z;

}
```


第二步进行冗余访问消除，假设代码中间注释掉的“do stuff...”所代表的操作不会改变b.value的值，那就可以把“z=b.value”替换为“z=y”，因为上一句“y=b.value”已经保证了变量y与b.value是一致的，这样就可以不再去访问对象b的局部变量了。



冗余存储消除的代码：

```java
public void foo() {

    y = b.value;

    // ...do stuff...

    z = y;

    sum = y + z;

}

```



第三步我们进行复写传播，因为在这段程序的逻辑中并没有必要使用一个额外的变量“z”，它与变量“y”是完全相等的，因此可以使用“y”来代替“z”。  

复写传播后的代码：

```java
public void foo() {
    y = b.value;
    // ...do stuff...
    y = y;
    sum = y + y;
}
```



第四步我们进行无用代码消除。无用代码可能是永远不会被执行的代码，也可能是完全没有意义的代码。

  消除无用代码：

```java
public void foo() {
    y = b.value;
    // ...do stuff...
    sum = y + y;
}
```



### 2.5 java与c/c++编译器对比

大多数程序员都认为C/C++会比Java语言快，甚至觉得从Java语言诞生以来“执行速度缓慢”的帽子就应当扣在它的头顶，这种观点的出现是由于`Java刚出现的时候即时编译技术还不成熟，主要靠解释器执行的Java语言性能确实比较低下`。但目前即时编译技术已经十分成熟，Java语言有可能在速度上与C/C++一争高下吗？要想知道这个问题的答案，让我们从两者的编译器谈起。

Java与C/C++的编译器对比，实际上代表了最经典的`即时编译器`与`静态编译器`的对比，很大程度上也决定了Java与C/C++的性能对比结果，因为无论是C/C++还是Java代码，最终编译之后被机器执行的都是本地机器码，哪种语言的性能更高，除了它们自身的`API库实现地好坏`之外，其余的比较就成了一场`拼编译器`的游戏。当然，这种比较也是剔除了开发效率的片面对比，语言孰优孰劣、谁快谁慢的问题都是很难有结果的争论，下面我们就回到正题，看看这两种语言的编译器各有何优势。



### 2.6 Java 编译器“劣势”的原因

Java虚拟机的即时编译器与C/C++的静态优化编译器相比，可能会由于下列原因，而导致输出的本地代码有一些劣势（下面列举的也包括一些虚拟机执行子系统的性能劣势）：

1. 因为即时编译器运行占用的是`用户程序的运行时间`，具有很大的时间压力，它能提供的优化手段也严重受制于编译成本。如果编译速度达不到要求，那用户将在启动程序或程序的某部分察觉到重大延迟，这点使得即时编译器不敢随便引入大规模的优化技术，而编译的时间成本在静态优化编译器中并不是主要的关注点。
2. Java语言是`动态的类型安全语言`，这就意味着需要由虚拟机来确保程序不会违反语言语义或访问非结构化内存。从实现层面上看，这就意味着虚拟机必须`频繁地进行动态检查`，如实例方法访问时检查空指针、数组元素访问时检查上下界范围、类型转换时检查继承关系等。对于这类程序代码没有明确写出的检查行为，尽管编译器会努力进行优化，但是总体上仍然要消耗不少的运行时间。
3. Java语言中虽然没有virtual关键字，但是`使用虚方法的频率却远远大于C/C++语言`，这意味着运行时对方法接收者进行多态选择的频率要远远大于C/C++语言，也意味着即时编译器在进行一些优化（如方法内联）时的难度要远远大于C/C++的静态优化编译器。
4. Java语言是可以`动态扩展`的语言，运行时加载新的类可能`改变程序类型的继承关系`，这使得很多`全局的优化难以进行`，因为编译器无法看清程序的全貌，许多全局的优化都只能以激进优化的方式来完成，编译器不得不时刻注意并随着类型的变化而在运行时撤销或重新进行一些优化。
5. Java语言的`对象内存是在堆上`，只有方法的局部变量才能在栈上分配，而C/C++的对象则有多重内存分配方式，既可能在堆上分配，又可能在栈上分配，如果可以在栈上分配线程私有的对象，将减轻内存回收的压力。另外，C/C++中主要由用户用程序代码来回收分配的内存，这就不存在无用对象筛选的过程，因此效率上（仅是运行效率，排除开发效率）也比Java的垃圾收集机制要高。

 

总结:

随着Java JIT编译技术的发展，Java的运行速度已经足够快（但是还是比C++慢）。Java能够在运行时动态加载类（可以从zip包、网络、运行时计算、其他文件生成），C/C++则完全做不到这一点。总的来说，Java的动态安全、动态扩展、垃圾回收等特性，使得开发效率很高，并且足够灵活；同时随着编译技术的不断发展，性能的劣势正在逐渐减小。

 

 

 

 

 

 

 

 

 